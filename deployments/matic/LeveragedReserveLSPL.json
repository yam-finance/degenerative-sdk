{
  "address": "0x00000000576179ed05F6D0AF1bb55d154aF59CFf",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "uint184",
          "name": "upperBound",
          "type": "uint184"
        }
      ],
      "name": "InvalidBound",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint72",
          "name": "pctLongCap",
          "type": "uint72"
        }
      ],
      "name": "InvalidCap",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint184",
          "name": "initialPrice",
          "type": "uint184"
        }
      ],
      "name": "InvalidInitialPrice",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "longShortPair",
          "type": "address"
        }
      ],
      "name": "InvalidLSPAddress",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint72",
          "name": "leverageFactor",
          "type": "uint72"
        }
      ],
      "name": "InvalidLeverage",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ParametersNotSet",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ParametersSet",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "longShortPairParameters",
      "outputs": [
        {
          "internalType": "uint184",
          "name": "upperBound",
          "type": "uint184"
        },
        {
          "internalType": "uint72",
          "name": "pctLongCap",
          "type": "uint72"
        },
        {
          "internalType": "uint184",
          "name": "initialPrice",
          "type": "uint184"
        },
        {
          "internalType": "uint72",
          "name": "leverageFactor",
          "type": "uint72"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "int256",
          "name": "expiryPrice",
          "type": "int256"
        }
      ],
      "name": "percentageLongCollateralAtExpiry",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "longShortPair",
          "type": "address"
        },
        {
          "internalType": "uint184",
          "name": "upperBound",
          "type": "uint184"
        },
        {
          "internalType": "uint72",
          "name": "pctLongCap",
          "type": "uint72"
        },
        {
          "internalType": "uint184",
          "name": "initialPrice",
          "type": "uint184"
        },
        {
          "internalType": "uint72",
          "name": "leverageFactor",
          "type": "uint72"
        }
      ],
      "name": "setLongShortPairParameters",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x0fbde2d2f862746d8a0b0fab95e8b8d1abd680e29061fda667dda0a0a8ee9555",
  "receipt": {
    "to": null,
    "from": "0xb33f42cfe5513E4Fd2686eC9f35Ab68eBD8fB097",
    "contractAddress": "0x00000000576179ed05F6D0AF1bb55d154aF59CFf",
    "transactionIndex": 82,
    "gasUsed": "653216",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000800000000000400000000100000000000000000000000000000000000000000000000000000000000080000008000000000000000000000000000000000000000000000000000000001000000000000000200000000000000000000000000000000000000000000000000000000000004000000000000000000001000000000000000000000000000000100000000000000000000000000400000000000000000000000000000000000000000000100000",
    "blockHash": "0x6da9784a60432a20d87088806eee8fc00f1d7e227910c3e0fec9b9b30a63da8f",
    "transactionHash": "0x0fbde2d2f862746d8a0b0fab95e8b8d1abd680e29061fda667dda0a0a8ee9555",
    "logs": [
      {
        "transactionIndex": 82,
        "blockNumber": 21694792,
        "transactionHash": "0x0fbde2d2f862746d8a0b0fab95e8b8d1abd680e29061fda667dda0a0a8ee9555",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x000000000000000000000000b33f42cfe5513e4fd2686ec9f35ab68ebd8fb097",
          "0x0000000000000000000000007c7379531b2aee82e4ca06d4175d13b9cbeafd49"
        ],
        "data": "0x00000000000000000000000000000000000000000000000000459ee50d3f800000000000000000000000000000000000000000000000000014d1120d7b160000000000000000000000000000000000000000000000003ed65799063d0e31999b000000000000000000000000000000000000000000000000148b73286dd68000000000000000000000000000000000000000000000003ed657dea5221b71199b",
        "logIndex": 793,
        "blockHash": "0x6da9784a60432a20d87088806eee8fc00f1d7e227910c3e0fec9b9b30a63da8f"
      }
    ],
    "blockNumber": 21694792,
    "cumulativeGasUsed": "19478464",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "solcInputHash": "aaf21535b65fe2dfc1d522cd60d041d6",
  "metadata": "{\"compiler\":{\"version\":\"0.8.9+commit.e5eed63a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint184\",\"name\":\"upperBound\",\"type\":\"uint184\"}],\"name\":\"InvalidBound\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint72\",\"name\":\"pctLongCap\",\"type\":\"uint72\"}],\"name\":\"InvalidCap\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint184\",\"name\":\"initialPrice\",\"type\":\"uint184\"}],\"name\":\"InvalidInitialPrice\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"longShortPair\",\"type\":\"address\"}],\"name\":\"InvalidLSPAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint72\",\"name\":\"leverageFactor\",\"type\":\"uint72\"}],\"name\":\"InvalidLeverage\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ParametersNotSet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ParametersSet\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"longShortPairParameters\",\"outputs\":[{\"internalType\":\"uint184\",\"name\":\"upperBound\",\"type\":\"uint184\"},{\"internalType\":\"uint72\",\"name\":\"pctLongCap\",\"type\":\"uint72\"},{\"internalType\":\"uint184\",\"name\":\"initialPrice\",\"type\":\"uint184\"},{\"internalType\":\"uint72\",\"name\":\"leverageFactor\",\"type\":\"uint72\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"expiryPrice\",\"type\":\"int256\"}],\"name\":\"percentageLongCollateralAtExpiry\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"longShortPair\",\"type\":\"address\"},{\"internalType\":\"uint184\",\"name\":\"upperBound\",\"type\":\"uint184\"},{\"internalType\":\"uint72\",\"name\":\"pctLongCap\",\"type\":\"uint72\"},{\"internalType\":\"uint184\",\"name\":\"initialPrice\",\"type\":\"uint184\"},{\"internalType\":\"uint72\",\"name\":\"leverageFactor\",\"type\":\"uint72\"}],\"name\":\"setLongShortPairParameters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"InvalidBound(uint184)\":[{\"params\":{\"upperBound\":\"The upper price that the LSP will operate within.\"}}],\"InvalidCap(uint72)\":[{\"params\":{\"pctLongCap\":\"The cap on the percentage that can be allocated to the long token - enforced for improving MM on v2 AMMs for both L&S tokens.\"}}],\"InvalidInitialPrice(uint184)\":[{\"params\":{\"initialPrice\":\"The price of the asset at LSP deployment, used to calculate returns.\"}}],\"InvalidLSPAddress(address)\":[{\"params\":{\"longShortPair\":\"The address of the LSP contract.\"}}],\"InvalidLeverage(uint72)\":[{\"params\":{\"leverageFactor\":\"The amount of leverage you want to apply to the asset return.\"}}]},\"kind\":\"dev\",\"methods\":{\"percentageLongCollateralAtExpiry(int256)\":{\"params\":{\"expiryPrice\":\"The price from the optimistic oracle for the LSP price identifier.\"},\"returns\":{\"_0\":\"expiryPercentLong to indicate how much collateral should be sent between long and short tokens.\"}},\"setLongShortPairParameters(address,uint184,uint72,uint184,uint72)\":{\"details\":\"Note:  a) Any address can set these parameters  b) For safety, parameters should be set before depositing any synthetic tokens in a liquidity pool.  c) The parameters are set for the LSP contract address  d) Parameters can only be set once to prevent the deployer from changing the parameters after the fact.  e) upperBound can't be zero.  f) pctLongCap can't be greater than or equal to 1 ether (100%).  g) longShortPair must expose an expirationTimestamp method to validate it is correctly deployed.\",\"params\":{\"initialPrice\":\"The price of the asset at LSP deployment, used to calculate returns.\",\"leverageFactor\":\"The amount of leverage you want to apply to the asset return.\",\"longShortPair\":\"The address of the LSP contract.\",\"pctLongCap\":\"The cap on the percentage that can be allocated to the long token - enforced for improving MM on v2 AMMs for both L&S tokens.\",\"upperBound\":\"The upper price that the LSP will operate within.\"}}},\"title\":\"Linear Long Short Pair Financial Product Library.\",\"version\":1},\"userdoc\":{\"errors\":{\"InvalidBound(uint184)\":[{\"notice\":\"`upperBound` has to be greater than zero.\"}],\"InvalidCap(uint72)\":[{\"notice\":\"`pctLongCap` has to be less than 1 ether.\"}],\"InvalidInitialPrice(uint184)\":[{\"notice\":\"`initialPrice` has to be greater than zero.\"}],\"InvalidLSPAddress(address)\":[{\"notice\":\"`longShortPair` is not a valid LSP address.\"}],\"InvalidLeverage(uint72)\":[{\"notice\":\"`leverageFactor` has to be greater than 0.\"}],\"ParametersNotSet()\":[{\"notice\":\"Parameters not set for calling LSP.\"}],\"ParametersSet()\":[{\"notice\":\"Parameters already set for calling LSP.\"}]},\"kind\":\"user\",\"methods\":{\"percentageLongCollateralAtExpiry(int256)\":{\"notice\":\"Returns a number between 0 and 1e18 to indicate how much collateral each long and short token is entitled to per collateralPerPair.\"},\"setLongShortPairParameters(address,uint184,uint72,uint184,uint72)\":{\"notice\":\"Enables any address to set the parameters for an associated financial product.\"}},\"notice\":\"Adds settlement logic to modify the linearLSP to allow for leveraged LSPs. Also includes a capped percentage payable to the long (& short) token to make market making both the long and short tokens easier in a v2 style AMM.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/LeveragedReserveLSPL.sol\":\"LeveragedReserveLSPL\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/utils/math/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x8666f020bd8fc9dc14f07e2ebc52b5f236ab4cdde7c77679b08cb2f94730043b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SignedSafeMath` is no longer needed starting with Solidity 0.8. The compiler\\n * now has built in overflow checking.\\n */\\nlibrary SignedSafeMath {\\n    /**\\n     * @dev Returns the multiplication of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(int256 a, int256 b) internal pure returns (int256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two signed integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(int256 a, int256 b) internal pure returns (int256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(int256 a, int256 b) internal pure returns (int256) {\\n        return a + b;\\n    }\\n}\\n\",\"keccak256\":\"0xd1ddc24b24f12a347093844dd645c3a96bcdce05d1f51b8650946ad404cb3c40\",\"license\":\"MIT\"},\"@uma/core/contracts/common/implementation/FixedPoint.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\\\";\\n\\n/**\\n * @title Library for fixed point arithmetic on uints\\n */\\nlibrary FixedPoint {\\n    using SafeMath for uint256;\\n    using SignedSafeMath for int256;\\n\\n    // Supports 18 decimals. E.g., 1e18 represents \\\"1\\\", 5e17 represents \\\"0.5\\\".\\n    // For unsigned values:\\n    //   This can represent a value up to (2^256 - 1)/10^18 = ~10^59. 10^59 will be stored internally as uint256 10^77.\\n    uint256 private constant FP_SCALING_FACTOR = 10**18;\\n\\n    // --------------------------------------- UNSIGNED -----------------------------------------------------------------------------\\n    struct Unsigned {\\n        uint256 rawValue;\\n    }\\n\\n    /**\\n     * @notice Constructs an `Unsigned` from an unscaled uint, e.g., `b=5` gets stored internally as `5*(10**18)`.\\n     * @param a uint to convert into a FixedPoint.\\n     * @return the converted FixedPoint.\\n     */\\n    function fromUnscaledUint(uint256 a) internal pure returns (Unsigned memory) {\\n        return Unsigned(a.mul(FP_SCALING_FACTOR));\\n    }\\n\\n    /**\\n     * @notice Whether `a` is equal to `b`.\\n     * @param a a FixedPoint.\\n     * @param b a uint256.\\n     * @return True if equal, or False.\\n     */\\n    function isEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\\n        return a.rawValue == fromUnscaledUint(b).rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is equal to `b`.\\n     * @param a a FixedPoint.\\n     * @param b a FixedPoint.\\n     * @return True if equal, or False.\\n     */\\n    function isEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\\n        return a.rawValue == b.rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is greater than `b`.\\n     * @param a a FixedPoint.\\n     * @param b a FixedPoint.\\n     * @return True if `a > b`, or False.\\n     */\\n    function isGreaterThan(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\\n        return a.rawValue > b.rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is greater than `b`.\\n     * @param a a FixedPoint.\\n     * @param b a uint256.\\n     * @return True if `a > b`, or False.\\n     */\\n    function isGreaterThan(Unsigned memory a, uint256 b) internal pure returns (bool) {\\n        return a.rawValue > fromUnscaledUint(b).rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is greater than `b`.\\n     * @param a a uint256.\\n     * @param b a FixedPoint.\\n     * @return True if `a > b`, or False.\\n     */\\n    function isGreaterThan(uint256 a, Unsigned memory b) internal pure returns (bool) {\\n        return fromUnscaledUint(a).rawValue > b.rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is greater than or equal to `b`.\\n     * @param a a FixedPoint.\\n     * @param b a FixedPoint.\\n     * @return True if `a >= b`, or False.\\n     */\\n    function isGreaterThanOrEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\\n        return a.rawValue >= b.rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is greater than or equal to `b`.\\n     * @param a a FixedPoint.\\n     * @param b a uint256.\\n     * @return True if `a >= b`, or False.\\n     */\\n    function isGreaterThanOrEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\\n        return a.rawValue >= fromUnscaledUint(b).rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is greater than or equal to `b`.\\n     * @param a a uint256.\\n     * @param b a FixedPoint.\\n     * @return True if `a >= b`, or False.\\n     */\\n    function isGreaterThanOrEqual(uint256 a, Unsigned memory b) internal pure returns (bool) {\\n        return fromUnscaledUint(a).rawValue >= b.rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is less than `b`.\\n     * @param a a FixedPoint.\\n     * @param b a FixedPoint.\\n     * @return True if `a < b`, or False.\\n     */\\n    function isLessThan(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\\n        return a.rawValue < b.rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is less than `b`.\\n     * @param a a FixedPoint.\\n     * @param b a uint256.\\n     * @return True if `a < b`, or False.\\n     */\\n    function isLessThan(Unsigned memory a, uint256 b) internal pure returns (bool) {\\n        return a.rawValue < fromUnscaledUint(b).rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is less than `b`.\\n     * @param a a uint256.\\n     * @param b a FixedPoint.\\n     * @return True if `a < b`, or False.\\n     */\\n    function isLessThan(uint256 a, Unsigned memory b) internal pure returns (bool) {\\n        return fromUnscaledUint(a).rawValue < b.rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is less than or equal to `b`.\\n     * @param a a FixedPoint.\\n     * @param b a FixedPoint.\\n     * @return True if `a <= b`, or False.\\n     */\\n    function isLessThanOrEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\\n        return a.rawValue <= b.rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is less than or equal to `b`.\\n     * @param a a FixedPoint.\\n     * @param b a uint256.\\n     * @return True if `a <= b`, or False.\\n     */\\n    function isLessThanOrEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\\n        return a.rawValue <= fromUnscaledUint(b).rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is less than or equal to `b`.\\n     * @param a a uint256.\\n     * @param b a FixedPoint.\\n     * @return True if `a <= b`, or False.\\n     */\\n    function isLessThanOrEqual(uint256 a, Unsigned memory b) internal pure returns (bool) {\\n        return fromUnscaledUint(a).rawValue <= b.rawValue;\\n    }\\n\\n    /**\\n     * @notice The minimum of `a` and `b`.\\n     * @param a a FixedPoint.\\n     * @param b a FixedPoint.\\n     * @return the minimum of `a` and `b`.\\n     */\\n    function min(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\\n        return a.rawValue < b.rawValue ? a : b;\\n    }\\n\\n    /**\\n     * @notice The maximum of `a` and `b`.\\n     * @param a a FixedPoint.\\n     * @param b a FixedPoint.\\n     * @return the maximum of `a` and `b`.\\n     */\\n    function max(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\\n        return a.rawValue > b.rawValue ? a : b;\\n    }\\n\\n    /**\\n     * @notice Adds two `Unsigned`s, reverting on overflow.\\n     * @param a a FixedPoint.\\n     * @param b a FixedPoint.\\n     * @return the sum of `a` and `b`.\\n     */\\n    function add(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\\n        return Unsigned(a.rawValue.add(b.rawValue));\\n    }\\n\\n    /**\\n     * @notice Adds an `Unsigned` to an unscaled uint, reverting on overflow.\\n     * @param a a FixedPoint.\\n     * @param b a uint256.\\n     * @return the sum of `a` and `b`.\\n     */\\n    function add(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\\n        return add(a, fromUnscaledUint(b));\\n    }\\n\\n    /**\\n     * @notice Subtracts two `Unsigned`s, reverting on overflow.\\n     * @param a a FixedPoint.\\n     * @param b a FixedPoint.\\n     * @return the difference of `a` and `b`.\\n     */\\n    function sub(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\\n        return Unsigned(a.rawValue.sub(b.rawValue));\\n    }\\n\\n    /**\\n     * @notice Subtracts an unscaled uint256 from an `Unsigned`, reverting on overflow.\\n     * @param a a FixedPoint.\\n     * @param b a uint256.\\n     * @return the difference of `a` and `b`.\\n     */\\n    function sub(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\\n        return sub(a, fromUnscaledUint(b));\\n    }\\n\\n    /**\\n     * @notice Subtracts an `Unsigned` from an unscaled uint256, reverting on overflow.\\n     * @param a a uint256.\\n     * @param b a FixedPoint.\\n     * @return the difference of `a` and `b`.\\n     */\\n    function sub(uint256 a, Unsigned memory b) internal pure returns (Unsigned memory) {\\n        return sub(fromUnscaledUint(a), b);\\n    }\\n\\n    /**\\n     * @notice Multiplies two `Unsigned`s, reverting on overflow.\\n     * @dev This will \\\"floor\\\" the product.\\n     * @param a a FixedPoint.\\n     * @param b a FixedPoint.\\n     * @return the product of `a` and `b`.\\n     */\\n    function mul(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\\n        // There are two caveats with this computation:\\n        // 1. Max output for the represented number is ~10^41, otherwise an intermediate value overflows. 10^41 is\\n        // stored internally as a uint256 ~10^59.\\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 1.4 * 2e-18 = 2.8e-18, which\\n        // would round to 3, but this computation produces the result 2.\\n        // No need to use SafeMath because FP_SCALING_FACTOR != 0.\\n        return Unsigned(a.rawValue.mul(b.rawValue) / FP_SCALING_FACTOR);\\n    }\\n\\n    /**\\n     * @notice Multiplies an `Unsigned` and an unscaled uint256, reverting on overflow.\\n     * @dev This will \\\"floor\\\" the product.\\n     * @param a a FixedPoint.\\n     * @param b a uint256.\\n     * @return the product of `a` and `b`.\\n     */\\n    function mul(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\\n        return Unsigned(a.rawValue.mul(b));\\n    }\\n\\n    /**\\n     * @notice Multiplies two `Unsigned`s and \\\"ceil's\\\" the product, reverting on overflow.\\n     * @param a a FixedPoint.\\n     * @param b a FixedPoint.\\n     * @return the product of `a` and `b`.\\n     */\\n    function mulCeil(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\\n        uint256 mulRaw = a.rawValue.mul(b.rawValue);\\n        uint256 mulFloor = mulRaw / FP_SCALING_FACTOR;\\n        uint256 mod = mulRaw.mod(FP_SCALING_FACTOR);\\n        if (mod != 0) {\\n            return Unsigned(mulFloor.add(1));\\n        } else {\\n            return Unsigned(mulFloor);\\n        }\\n    }\\n\\n    /**\\n     * @notice Multiplies an `Unsigned` and an unscaled uint256 and \\\"ceil's\\\" the product, reverting on overflow.\\n     * @param a a FixedPoint.\\n     * @param b a FixedPoint.\\n     * @return the product of `a` and `b`.\\n     */\\n    function mulCeil(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\\n        // Since b is an uint, there is no risk of truncation and we can just mul it normally\\n        return Unsigned(a.rawValue.mul(b));\\n    }\\n\\n    /**\\n     * @notice Divides one `Unsigned` by an `Unsigned`, reverting on overflow or division by 0.\\n     * @dev This will \\\"floor\\\" the quotient.\\n     * @param a a FixedPoint numerator.\\n     * @param b a FixedPoint denominator.\\n     * @return the quotient of `a` divided by `b`.\\n     */\\n    function div(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\\n        // There are two caveats with this computation:\\n        // 1. Max value for the number dividend `a` represents is ~10^41, otherwise an intermediate value overflows.\\n        // 10^41 is stored internally as a uint256 10^59.\\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 2 / 3 = 0.6 repeating, which\\n        // would round to 0.666666666666666667, but this computation produces the result 0.666666666666666666.\\n        return Unsigned(a.rawValue.mul(FP_SCALING_FACTOR).div(b.rawValue));\\n    }\\n\\n    /**\\n     * @notice Divides one `Unsigned` by an unscaled uint256, reverting on overflow or division by 0.\\n     * @dev This will \\\"floor\\\" the quotient.\\n     * @param a a FixedPoint numerator.\\n     * @param b a uint256 denominator.\\n     * @return the quotient of `a` divided by `b`.\\n     */\\n    function div(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\\n        return Unsigned(a.rawValue.div(b));\\n    }\\n\\n    /**\\n     * @notice Divides one unscaled uint256 by an `Unsigned`, reverting on overflow or division by 0.\\n     * @dev This will \\\"floor\\\" the quotient.\\n     * @param a a uint256 numerator.\\n     * @param b a FixedPoint denominator.\\n     * @return the quotient of `a` divided by `b`.\\n     */\\n    function div(uint256 a, Unsigned memory b) internal pure returns (Unsigned memory) {\\n        return div(fromUnscaledUint(a), b);\\n    }\\n\\n    /**\\n     * @notice Divides one `Unsigned` by an `Unsigned` and \\\"ceil's\\\" the quotient, reverting on overflow or division by 0.\\n     * @param a a FixedPoint numerator.\\n     * @param b a FixedPoint denominator.\\n     * @return the quotient of `a` divided by `b`.\\n     */\\n    function divCeil(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\\n        uint256 aScaled = a.rawValue.mul(FP_SCALING_FACTOR);\\n        uint256 divFloor = aScaled.div(b.rawValue);\\n        uint256 mod = aScaled.mod(b.rawValue);\\n        if (mod != 0) {\\n            return Unsigned(divFloor.add(1));\\n        } else {\\n            return Unsigned(divFloor);\\n        }\\n    }\\n\\n    /**\\n     * @notice Divides one `Unsigned` by an unscaled uint256 and \\\"ceil's\\\" the quotient, reverting on overflow or division by 0.\\n     * @param a a FixedPoint numerator.\\n     * @param b a uint256 denominator.\\n     * @return the quotient of `a` divided by `b`.\\n     */\\n    function divCeil(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\\n        // Because it is possible that a quotient gets truncated, we can't just call \\\"Unsigned(a.rawValue.div(b))\\\"\\n        // similarly to mulCeil with a uint256 as the second parameter. Therefore we need to convert b into an Unsigned.\\n        // This creates the possibility of overflow if b is very large.\\n        return divCeil(a, fromUnscaledUint(b));\\n    }\\n\\n    /**\\n     * @notice Raises an `Unsigned` to the power of an unscaled uint256, reverting on overflow. E.g., `b=2` squares `a`.\\n     * @dev This will \\\"floor\\\" the result.\\n     * @param a a FixedPoint numerator.\\n     * @param b a uint256 denominator.\\n     * @return output is `a` to the power of `b`.\\n     */\\n    function pow(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory output) {\\n        output = fromUnscaledUint(1);\\n        for (uint256 i = 0; i < b; i = i.add(1)) {\\n            output = mul(output, a);\\n        }\\n    }\\n\\n    // ------------------------------------------------- SIGNED -------------------------------------------------------------\\n    // Supports 18 decimals. E.g., 1e18 represents \\\"1\\\", 5e17 represents \\\"0.5\\\".\\n    // For signed values:\\n    //   This can represent a value up (or down) to +-(2^255 - 1)/10^18 = ~10^58. 10^58 will be stored internally as int256 10^76.\\n    int256 private constant SFP_SCALING_FACTOR = 10**18;\\n\\n    struct Signed {\\n        int256 rawValue;\\n    }\\n\\n    function fromSigned(Signed memory a) internal pure returns (Unsigned memory) {\\n        require(a.rawValue >= 0, \\\"Negative value provided\\\");\\n        return Unsigned(uint256(a.rawValue));\\n    }\\n\\n    function fromUnsigned(Unsigned memory a) internal pure returns (Signed memory) {\\n        require(a.rawValue <= uint256(type(int256).max), \\\"Unsigned too large\\\");\\n        return Signed(int256(a.rawValue));\\n    }\\n\\n    /**\\n     * @notice Constructs a `Signed` from an unscaled int, e.g., `b=5` gets stored internally as `5*(10**18)`.\\n     * @param a int to convert into a FixedPoint.Signed.\\n     * @return the converted FixedPoint.Signed.\\n     */\\n    function fromUnscaledInt(int256 a) internal pure returns (Signed memory) {\\n        return Signed(a.mul(SFP_SCALING_FACTOR));\\n    }\\n\\n    /**\\n     * @notice Whether `a` is equal to `b`.\\n     * @param a a FixedPoint.Signed.\\n     * @param b a int256.\\n     * @return True if equal, or False.\\n     */\\n    function isEqual(Signed memory a, int256 b) internal pure returns (bool) {\\n        return a.rawValue == fromUnscaledInt(b).rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is equal to `b`.\\n     * @param a a FixedPoint.Signed.\\n     * @param b a FixedPoint.Signed.\\n     * @return True if equal, or False.\\n     */\\n    function isEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\\n        return a.rawValue == b.rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is greater than `b`.\\n     * @param a a FixedPoint.Signed.\\n     * @param b a FixedPoint.Signed.\\n     * @return True if `a > b`, or False.\\n     */\\n    function isGreaterThan(Signed memory a, Signed memory b) internal pure returns (bool) {\\n        return a.rawValue > b.rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is greater than `b`.\\n     * @param a a FixedPoint.Signed.\\n     * @param b an int256.\\n     * @return True if `a > b`, or False.\\n     */\\n    function isGreaterThan(Signed memory a, int256 b) internal pure returns (bool) {\\n        return a.rawValue > fromUnscaledInt(b).rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is greater than `b`.\\n     * @param a an int256.\\n     * @param b a FixedPoint.Signed.\\n     * @return True if `a > b`, or False.\\n     */\\n    function isGreaterThan(int256 a, Signed memory b) internal pure returns (bool) {\\n        return fromUnscaledInt(a).rawValue > b.rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is greater than or equal to `b`.\\n     * @param a a FixedPoint.Signed.\\n     * @param b a FixedPoint.Signed.\\n     * @return True if `a >= b`, or False.\\n     */\\n    function isGreaterThanOrEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\\n        return a.rawValue >= b.rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is greater than or equal to `b`.\\n     * @param a a FixedPoint.Signed.\\n     * @param b an int256.\\n     * @return True if `a >= b`, or False.\\n     */\\n    function isGreaterThanOrEqual(Signed memory a, int256 b) internal pure returns (bool) {\\n        return a.rawValue >= fromUnscaledInt(b).rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is greater than or equal to `b`.\\n     * @param a an int256.\\n     * @param b a FixedPoint.Signed.\\n     * @return True if `a >= b`, or False.\\n     */\\n    function isGreaterThanOrEqual(int256 a, Signed memory b) internal pure returns (bool) {\\n        return fromUnscaledInt(a).rawValue >= b.rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is less than `b`.\\n     * @param a a FixedPoint.Signed.\\n     * @param b a FixedPoint.Signed.\\n     * @return True if `a < b`, or False.\\n     */\\n    function isLessThan(Signed memory a, Signed memory b) internal pure returns (bool) {\\n        return a.rawValue < b.rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is less than `b`.\\n     * @param a a FixedPoint.Signed.\\n     * @param b an int256.\\n     * @return True if `a < b`, or False.\\n     */\\n    function isLessThan(Signed memory a, int256 b) internal pure returns (bool) {\\n        return a.rawValue < fromUnscaledInt(b).rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is less than `b`.\\n     * @param a an int256.\\n     * @param b a FixedPoint.Signed.\\n     * @return True if `a < b`, or False.\\n     */\\n    function isLessThan(int256 a, Signed memory b) internal pure returns (bool) {\\n        return fromUnscaledInt(a).rawValue < b.rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is less than or equal to `b`.\\n     * @param a a FixedPoint.Signed.\\n     * @param b a FixedPoint.Signed.\\n     * @return True if `a <= b`, or False.\\n     */\\n    function isLessThanOrEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\\n        return a.rawValue <= b.rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is less than or equal to `b`.\\n     * @param a a FixedPoint.Signed.\\n     * @param b an int256.\\n     * @return True if `a <= b`, or False.\\n     */\\n    function isLessThanOrEqual(Signed memory a, int256 b) internal pure returns (bool) {\\n        return a.rawValue <= fromUnscaledInt(b).rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is less than or equal to `b`.\\n     * @param a an int256.\\n     * @param b a FixedPoint.Signed.\\n     * @return True if `a <= b`, or False.\\n     */\\n    function isLessThanOrEqual(int256 a, Signed memory b) internal pure returns (bool) {\\n        return fromUnscaledInt(a).rawValue <= b.rawValue;\\n    }\\n\\n    /**\\n     * @notice The minimum of `a` and `b`.\\n     * @param a a FixedPoint.Signed.\\n     * @param b a FixedPoint.Signed.\\n     * @return the minimum of `a` and `b`.\\n     */\\n    function min(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\\n        return a.rawValue < b.rawValue ? a : b;\\n    }\\n\\n    /**\\n     * @notice The maximum of `a` and `b`.\\n     * @param a a FixedPoint.Signed.\\n     * @param b a FixedPoint.Signed.\\n     * @return the maximum of `a` and `b`.\\n     */\\n    function max(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\\n        return a.rawValue > b.rawValue ? a : b;\\n    }\\n\\n    /**\\n     * @notice Adds two `Signed`s, reverting on overflow.\\n     * @param a a FixedPoint.Signed.\\n     * @param b a FixedPoint.Signed.\\n     * @return the sum of `a` and `b`.\\n     */\\n    function add(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\\n        return Signed(a.rawValue.add(b.rawValue));\\n    }\\n\\n    /**\\n     * @notice Adds an `Signed` to an unscaled int, reverting on overflow.\\n     * @param a a FixedPoint.Signed.\\n     * @param b an int256.\\n     * @return the sum of `a` and `b`.\\n     */\\n    function add(Signed memory a, int256 b) internal pure returns (Signed memory) {\\n        return add(a, fromUnscaledInt(b));\\n    }\\n\\n    /**\\n     * @notice Subtracts two `Signed`s, reverting on overflow.\\n     * @param a a FixedPoint.Signed.\\n     * @param b a FixedPoint.Signed.\\n     * @return the difference of `a` and `b`.\\n     */\\n    function sub(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\\n        return Signed(a.rawValue.sub(b.rawValue));\\n    }\\n\\n    /**\\n     * @notice Subtracts an unscaled int256 from an `Signed`, reverting on overflow.\\n     * @param a a FixedPoint.Signed.\\n     * @param b an int256.\\n     * @return the difference of `a` and `b`.\\n     */\\n    function sub(Signed memory a, int256 b) internal pure returns (Signed memory) {\\n        return sub(a, fromUnscaledInt(b));\\n    }\\n\\n    /**\\n     * @notice Subtracts an `Signed` from an unscaled int256, reverting on overflow.\\n     * @param a an int256.\\n     * @param b a FixedPoint.Signed.\\n     * @return the difference of `a` and `b`.\\n     */\\n    function sub(int256 a, Signed memory b) internal pure returns (Signed memory) {\\n        return sub(fromUnscaledInt(a), b);\\n    }\\n\\n    /**\\n     * @notice Multiplies two `Signed`s, reverting on overflow.\\n     * @dev This will \\\"floor\\\" the product.\\n     * @param a a FixedPoint.Signed.\\n     * @param b a FixedPoint.Signed.\\n     * @return the product of `a` and `b`.\\n     */\\n    function mul(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\\n        // There are two caveats with this computation:\\n        // 1. Max output for the represented number is ~10^41, otherwise an intermediate value overflows. 10^41 is\\n        // stored internally as an int256 ~10^59.\\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 1.4 * 2e-18 = 2.8e-18, which\\n        // would round to 3, but this computation produces the result 2.\\n        // No need to use SafeMath because SFP_SCALING_FACTOR != 0.\\n        return Signed(a.rawValue.mul(b.rawValue) / SFP_SCALING_FACTOR);\\n    }\\n\\n    /**\\n     * @notice Multiplies an `Signed` and an unscaled int256, reverting on overflow.\\n     * @dev This will \\\"floor\\\" the product.\\n     * @param a a FixedPoint.Signed.\\n     * @param b an int256.\\n     * @return the product of `a` and `b`.\\n     */\\n    function mul(Signed memory a, int256 b) internal pure returns (Signed memory) {\\n        return Signed(a.rawValue.mul(b));\\n    }\\n\\n    /**\\n     * @notice Multiplies two `Signed`s and \\\"ceil's\\\" the product, reverting on overflow.\\n     * @param a a FixedPoint.Signed.\\n     * @param b a FixedPoint.Signed.\\n     * @return the product of `a` and `b`.\\n     */\\n    function mulAwayFromZero(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\\n        int256 mulRaw = a.rawValue.mul(b.rawValue);\\n        int256 mulTowardsZero = mulRaw / SFP_SCALING_FACTOR;\\n        // Manual mod because SignedSafeMath doesn't support it.\\n        int256 mod = mulRaw % SFP_SCALING_FACTOR;\\n        if (mod != 0) {\\n            bool isResultPositive = isLessThan(a, 0) == isLessThan(b, 0);\\n            int256 valueToAdd = isResultPositive ? int256(1) : int256(-1);\\n            return Signed(mulTowardsZero.add(valueToAdd));\\n        } else {\\n            return Signed(mulTowardsZero);\\n        }\\n    }\\n\\n    /**\\n     * @notice Multiplies an `Signed` and an unscaled int256 and \\\"ceil's\\\" the product, reverting on overflow.\\n     * @param a a FixedPoint.Signed.\\n     * @param b a FixedPoint.Signed.\\n     * @return the product of `a` and `b`.\\n     */\\n    function mulAwayFromZero(Signed memory a, int256 b) internal pure returns (Signed memory) {\\n        // Since b is an int, there is no risk of truncation and we can just mul it normally\\n        return Signed(a.rawValue.mul(b));\\n    }\\n\\n    /**\\n     * @notice Divides one `Signed` by an `Signed`, reverting on overflow or division by 0.\\n     * @dev This will \\\"floor\\\" the quotient.\\n     * @param a a FixedPoint numerator.\\n     * @param b a FixedPoint denominator.\\n     * @return the quotient of `a` divided by `b`.\\n     */\\n    function div(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\\n        // There are two caveats with this computation:\\n        // 1. Max value for the number dividend `a` represents is ~10^41, otherwise an intermediate value overflows.\\n        // 10^41 is stored internally as an int256 10^59.\\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 2 / 3 = 0.6 repeating, which\\n        // would round to 0.666666666666666667, but this computation produces the result 0.666666666666666666.\\n        return Signed(a.rawValue.mul(SFP_SCALING_FACTOR).div(b.rawValue));\\n    }\\n\\n    /**\\n     * @notice Divides one `Signed` by an unscaled int256, reverting on overflow or division by 0.\\n     * @dev This will \\\"floor\\\" the quotient.\\n     * @param a a FixedPoint numerator.\\n     * @param b an int256 denominator.\\n     * @return the quotient of `a` divided by `b`.\\n     */\\n    function div(Signed memory a, int256 b) internal pure returns (Signed memory) {\\n        return Signed(a.rawValue.div(b));\\n    }\\n\\n    /**\\n     * @notice Divides one unscaled int256 by an `Signed`, reverting on overflow or division by 0.\\n     * @dev This will \\\"floor\\\" the quotient.\\n     * @param a an int256 numerator.\\n     * @param b a FixedPoint denominator.\\n     * @return the quotient of `a` divided by `b`.\\n     */\\n    function div(int256 a, Signed memory b) internal pure returns (Signed memory) {\\n        return div(fromUnscaledInt(a), b);\\n    }\\n\\n    /**\\n     * @notice Divides one `Signed` by an `Signed` and \\\"ceil's\\\" the quotient, reverting on overflow or division by 0.\\n     * @param a a FixedPoint numerator.\\n     * @param b a FixedPoint denominator.\\n     * @return the quotient of `a` divided by `b`.\\n     */\\n    function divAwayFromZero(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\\n        int256 aScaled = a.rawValue.mul(SFP_SCALING_FACTOR);\\n        int256 divTowardsZero = aScaled.div(b.rawValue);\\n        // Manual mod because SignedSafeMath doesn't support it.\\n        int256 mod = aScaled % b.rawValue;\\n        if (mod != 0) {\\n            bool isResultPositive = isLessThan(a, 0) == isLessThan(b, 0);\\n            int256 valueToAdd = isResultPositive ? int256(1) : int256(-1);\\n            return Signed(divTowardsZero.add(valueToAdd));\\n        } else {\\n            return Signed(divTowardsZero);\\n        }\\n    }\\n\\n    /**\\n     * @notice Divides one `Signed` by an unscaled int256 and \\\"ceil's\\\" the quotient, reverting on overflow or division by 0.\\n     * @param a a FixedPoint numerator.\\n     * @param b an int256 denominator.\\n     * @return the quotient of `a` divided by `b`.\\n     */\\n    function divAwayFromZero(Signed memory a, int256 b) internal pure returns (Signed memory) {\\n        // Because it is possible that a quotient gets truncated, we can't just call \\\"Signed(a.rawValue.div(b))\\\"\\n        // similarly to mulCeil with an int256 as the second parameter. Therefore we need to convert b into an Signed.\\n        // This creates the possibility of overflow if b is very large.\\n        return divAwayFromZero(a, fromUnscaledInt(b));\\n    }\\n\\n    /**\\n     * @notice Raises an `Signed` to the power of an unscaled uint256, reverting on overflow. E.g., `b=2` squares `a`.\\n     * @dev This will \\\"floor\\\" the result.\\n     * @param a a FixedPoint.Signed.\\n     * @param b a uint256 (negative exponents are not allowed).\\n     * @return output is `a` to the power of `b`.\\n     */\\n    function pow(Signed memory a, uint256 b) internal pure returns (Signed memory output) {\\n        output = fromUnscaledInt(1);\\n        for (uint256 i = 0; i < b; i = i.add(1)) {\\n            output = mul(output, a);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x996b97cc4fa5da4064e3aee500edc6972485d59a9334ceec81155e2c2f484dae\",\"license\":\"AGPL-3.0-only\"},\"@uma/core/contracts/common/implementation/Lockable.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title A contract that provides modifiers to prevent reentrancy to state-changing and view-only methods. This contract\\n * is inspired by https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/ReentrancyGuard.sol\\n * and https://github.com/balancer-labs/balancer-core/blob/master/contracts/BPool.sol.\\n */\\ncontract Lockable {\\n    bool private _notEntered;\\n\\n    constructor() {\\n        // Storing an initial non-zero value makes deployment a bit more expensive, but in exchange the refund on every\\n        // call to nonReentrant will be lower in amount. Since refunds are capped to a percentage of the total\\n        // transaction's gas, it is best to keep them low in cases like this one, to increase the likelihood of the full\\n        // refund coming into effect.\\n        _notEntered = true;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant` function is not supported. It is possible to\\n     * prevent this from happening by making the `nonReentrant` function external, and making it call a `private`\\n     * function that does the actual state modification.\\n     */\\n    modifier nonReentrant() {\\n        _preEntranceCheck();\\n        _preEntranceSet();\\n        _;\\n        _postEntranceReset();\\n    }\\n\\n    /**\\n     * @dev Designed to prevent a view-only method from being re-entered during a call to a `nonReentrant()` state-changing method.\\n     */\\n    modifier nonReentrantView() {\\n        _preEntranceCheck();\\n        _;\\n    }\\n\\n    // Internal methods are used to avoid copying the require statement's bytecode to every `nonReentrant()` method.\\n    // On entry into a function, `_preEntranceCheck()` should always be called to check if the function is being\\n    // re-entered. Then, if the function modifies state, it should call `_postEntranceSet()`, perform its logic, and\\n    // then call `_postEntranceReset()`.\\n    // View-only methods can simply call `_preEntranceCheck()` to make sure that it is not being re-entered.\\n    function _preEntranceCheck() internal view {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_notEntered, \\\"ReentrancyGuard: reentrant call\\\");\\n    }\\n\\n    function _preEntranceSet() internal {\\n        // Any calls to nonReentrant after this point will fail\\n        _notEntered = false;\\n    }\\n\\n    function _postEntranceReset() internal {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _notEntered = true;\\n    }\\n}\\n\",\"keccak256\":\"0xcd34b3f83b61a096b53020749f327096d5cacd89c2393d947595afb934496ad4\",\"license\":\"AGPL-3.0-only\"},\"@uma/core/contracts/financial-templates/common/financial-product-libraries/long-short-pair-libraries/LongShortPairFinancialProductLibrary.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.0;\\nimport \\\"../../../../common/implementation/FixedPoint.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\n\\ninterface ExpiringContractInterface {\\n    function expirationTimestamp() external view returns (uint256);\\n}\\n\\nabstract contract LongShortPairFinancialProductLibrary {\\n    function percentageLongCollateralAtExpiry(int256 expiryPrice) public view virtual returns (uint256);\\n}\\n\",\"keccak256\":\"0x74229dc41c9be406f5b038f5e7e42403355110559e5f37ade5ed3d547020cfae\",\"license\":\"AGPL-3.0-only\"},\"contracts/LeveragedReserveLSPL.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.9;\\n\\nimport \\\"@uma/core/contracts/financial-templates/common/financial-product-libraries/long-short-pair-libraries/LongShortPairFinancialProductLibrary.sol\\\";\\nimport \\\"@uma/core/contracts/common/implementation/Lockable.sol\\\";\\n\\n/**\\n * @title Linear Long Short Pair Financial Product Library.\\n * @notice Adds settlement logic to modify the linearLSP to allow for leveraged LSPs.\\n * Also includes a capped percentage payable to the long (& short) token to\\n * make market making both the long and short tokens easier in a v2 style AMM.\\n */\\ncontract LeveragedReserveLSPL is LongShortPairFinancialProductLibrary, Lockable {\\n    struct LeveragedReserveLongShortPairParameters {\\n        uint184 upperBound;\\n        uint72 pctLongCap;\\n        uint184 initialPrice;\\n        uint72 leverageFactor;\\n    }\\n\\n    mapping(address => LeveragedReserveLongShortPairParameters) public longShortPairParameters;\\n\\n    /// `longShortPair` is not a valid LSP address.\\n    /// @param longShortPair The address of the LSP contract.\\n    error InvalidLSPAddress(address longShortPair);\\n\\n    /// `upperBound` has to be greater than zero.\\n    /// @param upperBound The upper price that the LSP will operate within.\\n    error InvalidBound(uint184 upperBound);\\n\\n    /// `pctLongCap` has to be less than 1 ether.\\n    /// @param pctLongCap The cap on the percentage that can be allocated to the long token - enforced for improving MM on v2 AMMs for both L&S tokens.\\n    error InvalidCap(uint72 pctLongCap);\\n\\n    /// `initialPrice` has to be greater than zero.\\n    /// @param initialPrice The price of the asset at LSP deployment, used to calculate returns.\\n    error InvalidInitialPrice(uint184 initialPrice);\\n\\n    /// `leverageFactor` has to be greater than 0.\\n    /// @param leverageFactor The amount of leverage you want to apply to the asset return.\\n    error InvalidLeverage(uint72 leverageFactor);\\n\\n    /// @notice Parameters already set for calling LSP.\\n    error ParametersSet();\\n\\n    /// @notice Parameters not set for calling LSP.\\n    error ParametersNotSet();\\n\\n    /**\\n     * @notice Enables any address to set the parameters for an associated financial product.\\n     * @param longShortPair The address of the LSP contract.\\n     * @param upperBound The upper price that the LSP will operate within.\\n     * @param pctLongCap The cap on the percentage that can be allocated to the long token - enforced for improving MM on v2 AMMs for both L&S tokens.\\n     * @param initialPrice The price of the asset at LSP deployment, used to calculate returns.\\n     * @param leverageFactor The amount of leverage you want to apply to the asset return.\\n     * @dev Note:\\n     *  a) Any address can set these parameters\\n     *  b) For safety, parameters should be set before depositing any synthetic tokens in a liquidity pool.\\n     *  c) The parameters are set for the LSP contract address\\n     *  d) Parameters can only be set once to prevent the deployer from changing the parameters after the fact.\\n     *  e) upperBound can't be zero.\\n     *  f) pctLongCap can't be greater than or equal to 1 ether (100%).\\n     *  g) longShortPair must expose an expirationTimestamp method to validate it is correctly deployed.\\n     */\\n    function setLongShortPairParameters(\\n        address longShortPair,\\n        uint184 upperBound,\\n        uint72 pctLongCap,\\n        uint184 initialPrice,\\n        uint72 leverageFactor\\n    ) public nonReentrant {\\n        if (ExpiringContractInterface(longShortPair).expirationTimestamp() == 0)\\n            revert InvalidLSPAddress(longShortPair);\\n        if (upperBound == 0) revert InvalidBound(upperBound);\\n        if (pctLongCap >= 1 ether) revert InvalidCap(pctLongCap);\\n        if (initialPrice == 0) revert InvalidInitialPrice(initialPrice);\\n        if (leverageFactor == 0) revert InvalidLeverage(leverageFactor);\\n\\n        LeveragedReserveLongShortPairParameters memory params = longShortPairParameters[longShortPair];\\n\\n        if (params.upperBound != 0) revert ParametersSet();\\n\\n        longShortPairParameters[longShortPair] = LeveragedReserveLongShortPairParameters({\\n            upperBound: upperBound,\\n            pctLongCap: pctLongCap,\\n            initialPrice: initialPrice,\\n            leverageFactor: leverageFactor\\n        });\\n    }\\n\\n    /**\\n     * @notice Returns a number between 0 and 1e18 to indicate how much collateral each long and short token is entitled\\n     * to per collateralPerPair.\\n     * @param expiryPrice The price from the optimistic oracle for the LSP price identifier.\\n     * @return expiryPercentLong to indicate how much collateral should be sent between long and short tokens.\\n     */\\n    function percentageLongCollateralAtExpiry(int256 expiryPrice)\\n        public\\n        view\\n        override\\n        nonReentrantView\\n        returns (uint256)\\n    {\\n        LeveragedReserveLongShortPairParameters memory params = longShortPairParameters[msg.sender];\\n        if (params.upperBound == 0) revert ParametersNotSet();\\n        if (expiryPrice <= 0) return (1 ether - params.pctLongCap);\\n        if (expiryPrice >= int184(params.upperBound)) return params.pctLongCap;\\n\\n        int256 unScaledReturnFactor = ((expiryPrice) * 1 ether) / int256(int184(params.initialPrice)) - 1 ether;\\n        int256 scaledReturnFactor = (unScaledReturnFactor * int256(int72(params.leverageFactor))) / 1 ether;\\n\\n        // scaledPrice = (upperBound * 1 ether / 2 ether) * (returnFactor + 1 ether) / 1 ether)\\n        uint256 scaledPrice = uint256(\\n            ((int256((int184(params.upperBound) * 1 ether)) / 2 ether) * (scaledReturnFactor + 1 ether)) / 1 ether\\n        );\\n\\n        uint256 effectiveUpperBound = (params.upperBound * params.pctLongCap) / 1 ether;\\n        uint256 effectiveLowerBound = (params.upperBound * (1 ether - params.pctLongCap)) / 1 ether;\\n        if (scaledPrice >= effectiveUpperBound) return params.pctLongCap;\\n        if (scaledPrice <= effectiveLowerBound) return (1 ether - params.pctLongCap);\\n        return (scaledPrice * 1 ether) / params.upperBound;\\n    }\\n}\\n\",\"keccak256\":\"0x068f550f4f516a26f5096daf2bb620a47e94fbc9017593e137990cd62ff22043\",\"license\":\"AGPL-3.0-only\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b506000805460ff19166001179055610a748061002d6000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c80632da52361146100465780636760f09b1461006c5780639299cbed14610081575b600080fd5b61005961005436600461069d565b61010b565b6040519081526020015b60405180910390f35b61007f61007a3660046106fb565b6103ad565b005b6100d161008f366004610760565b600160208190526000918252604090912080549101546001600160b81b03808316926001600160481b03600160b81b9182900481169392831692919091041684565b604080516001600160b81b0395861681526001600160481b0394851660208201529490921691840191909152166060820152608001610063565b6000610115610649565b33600090815260016020818152604092839020835160808101855281546001600160b81b038082168084526001600160481b03600160b81b938490048116968501969096529390950154948516958201959095529390920416606083015261019057604051636ba8dee360e01b815260040160405180910390fd5b600083136101bf5760208101516101af90670de0b6b3a7640000610798565b6001600160481b03169392505050565b805160160b83126101dd57602001516001600160481b031692915050565b6000670de0b6b3a7640000826040015160160b85670de0b6b3a764000061020491906107c0565b61020e919061085b565b6102189190610889565b90506000670de0b6b3a7640000836060015160080b8361023891906107c0565b610242919061085b565b90506000670de0b6b3a764000061025983826108c8565b8551671bc16d674ec800009061027790670de0b6b3a7640000610909565b60160b610284919061085b565b61028e91906107c0565b610298919061085b565b90506000670de0b6b3a764000085602001516001600160481b031686600001516102c2919061099d565b6102cc91906109cc565b6001600160b81b031690506000670de0b6b3a76400008660200151670de0b6b3a76400006102fa9190610798565b875161030f916001600160481b03169061099d565b61031991906109cc565b6001600160b81b03169050818310610345575050506020909201516001600160481b0316949350505050565b80831161037857602086015161036390670de0b6b3a7640000610798565b6001600160481b031698975050505050505050565b85516001600160b81b031661039584670de0b6b3a76400006109f2565b61039f9190610a11565b96505050505050505b919050565b6103b5610649565b6103c46000805460ff19169055565b846001600160a01b0316639f43ddd26040518163ffffffff1660e01b815260040160206040518083038186803b1580156103fd57600080fd5b505afa158015610411573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104359190610a25565b6104625760405163d096610560e01b81526001600160a01b03861660048201526024015b60405180910390fd5b6001600160b81b038416610494576040516351a22ceb60e11b81526001600160b81b0385166004820152602401610459565b670de0b6b3a7640000836001600160481b0316106104d057604051632ea539c360e01b81526001600160481b0384166004820152602401610459565b6001600160b81b0382166105025760405163158022fb60e11b81526001600160b81b0383166004820152602401610459565b6001600160481b03811661053457604051636e66464f60e01b81526001600160481b0382166004820152602401610459565b6001600160a01b038516600090815260016020818152604092839020835160808101855281546001600160b81b038082168084526001600160481b03600160b81b9384900481169685019690965293909501549485169582019590955293909204166060830152156105b957604051633190ad1960e01b815260040160405180910390fd5b50604080516080810182526001600160b81b0386811682526001600160481b038681166020808501918252878416858701908152878416606087019081526001600160a01b038d16600090815260019384905297882096519351938616600160b81b948616850217875590519051941693909216029190911791810191909155815460ff19161790555050505050565b60005460ff1661069b5760405162461bcd60e51b815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c006044820152606401610459565b565b6000602082840312156106af57600080fd5b5035919050565b80356001600160a01b03811681146103a857600080fd5b80356001600160b81b03811681146103a857600080fd5b80356001600160481b03811681146103a857600080fd5b600080600080600060a0868803121561071357600080fd5b61071c866106b6565b945061072a602087016106cd565b9350610738604087016106e4565b9250610746606087016106cd565b9150610754608087016106e4565b90509295509295909350565b60006020828403121561077257600080fd5b61077b826106b6565b9392505050565b634e487b7160e01b600052601160045260246000fd5b60006001600160481b03838116908316818110156107b8576107b8610782565b039392505050565b60006001600160ff1b03818413828413808216868404861116156107e6576107e6610782565b600160ff1b600087128281168783058912161561080557610805610782565b6000871292508782058712848416161561082157610821610782565b8785058712818416161561083757610837610782565b505050929093029392505050565b634e487b7160e01b600052601260045260246000fd5b60008261086a5761086a610845565b600160ff1b82146000198414161561088457610884610782565b500590565b60008083128015600160ff1b8501841216156108a7576108a7610782565b6001600160ff1b03840183138116156108c2576108c2610782565b50500390565b600080821280156001600160ff1b03849003851316156108ea576108ea610782565b600160ff1b839003841281161561090357610903610782565b50500190565b6000601682810b9084900b6001600160b71b038382138484138082168484048611161561093857610938610782565b6001600160b71b0319600085128281168783058712161561095b5761095b610782565b6000871292508582058712848416161561097757610977610782565b8585058712818416161561098d5761098d610782565b5050509290910295945050505050565b60006001600160b81b03828116848216811515828404821116156109c3576109c3610782565b02949350505050565b60006001600160b81b03838116806109e6576109e6610845565b92169190910492915050565b6000816000190483118215151615610a0c57610a0c610782565b500290565b600082610a2057610a20610845565b500490565b600060208284031215610a3757600080fd5b505191905056fea2646970667358221220d285086e6f155361e6f84cd239727144d7679378137f6578431df55b87f29c0364736f6c63430008090033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100415760003560e01c80632da52361146100465780636760f09b1461006c5780639299cbed14610081575b600080fd5b61005961005436600461069d565b61010b565b6040519081526020015b60405180910390f35b61007f61007a3660046106fb565b6103ad565b005b6100d161008f366004610760565b600160208190526000918252604090912080549101546001600160b81b03808316926001600160481b03600160b81b9182900481169392831692919091041684565b604080516001600160b81b0395861681526001600160481b0394851660208201529490921691840191909152166060820152608001610063565b6000610115610649565b33600090815260016020818152604092839020835160808101855281546001600160b81b038082168084526001600160481b03600160b81b938490048116968501969096529390950154948516958201959095529390920416606083015261019057604051636ba8dee360e01b815260040160405180910390fd5b600083136101bf5760208101516101af90670de0b6b3a7640000610798565b6001600160481b03169392505050565b805160160b83126101dd57602001516001600160481b031692915050565b6000670de0b6b3a7640000826040015160160b85670de0b6b3a764000061020491906107c0565b61020e919061085b565b6102189190610889565b90506000670de0b6b3a7640000836060015160080b8361023891906107c0565b610242919061085b565b90506000670de0b6b3a764000061025983826108c8565b8551671bc16d674ec800009061027790670de0b6b3a7640000610909565b60160b610284919061085b565b61028e91906107c0565b610298919061085b565b90506000670de0b6b3a764000085602001516001600160481b031686600001516102c2919061099d565b6102cc91906109cc565b6001600160b81b031690506000670de0b6b3a76400008660200151670de0b6b3a76400006102fa9190610798565b875161030f916001600160481b03169061099d565b61031991906109cc565b6001600160b81b03169050818310610345575050506020909201516001600160481b0316949350505050565b80831161037857602086015161036390670de0b6b3a7640000610798565b6001600160481b031698975050505050505050565b85516001600160b81b031661039584670de0b6b3a76400006109f2565b61039f9190610a11565b96505050505050505b919050565b6103b5610649565b6103c46000805460ff19169055565b846001600160a01b0316639f43ddd26040518163ffffffff1660e01b815260040160206040518083038186803b1580156103fd57600080fd5b505afa158015610411573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104359190610a25565b6104625760405163d096610560e01b81526001600160a01b03861660048201526024015b60405180910390fd5b6001600160b81b038416610494576040516351a22ceb60e11b81526001600160b81b0385166004820152602401610459565b670de0b6b3a7640000836001600160481b0316106104d057604051632ea539c360e01b81526001600160481b0384166004820152602401610459565b6001600160b81b0382166105025760405163158022fb60e11b81526001600160b81b0383166004820152602401610459565b6001600160481b03811661053457604051636e66464f60e01b81526001600160481b0382166004820152602401610459565b6001600160a01b038516600090815260016020818152604092839020835160808101855281546001600160b81b038082168084526001600160481b03600160b81b9384900481169685019690965293909501549485169582019590955293909204166060830152156105b957604051633190ad1960e01b815260040160405180910390fd5b50604080516080810182526001600160b81b0386811682526001600160481b038681166020808501918252878416858701908152878416606087019081526001600160a01b038d16600090815260019384905297882096519351938616600160b81b948616850217875590519051941693909216029190911791810191909155815460ff19161790555050505050565b60005460ff1661069b5760405162461bcd60e51b815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c006044820152606401610459565b565b6000602082840312156106af57600080fd5b5035919050565b80356001600160a01b03811681146103a857600080fd5b80356001600160b81b03811681146103a857600080fd5b80356001600160481b03811681146103a857600080fd5b600080600080600060a0868803121561071357600080fd5b61071c866106b6565b945061072a602087016106cd565b9350610738604087016106e4565b9250610746606087016106cd565b9150610754608087016106e4565b90509295509295909350565b60006020828403121561077257600080fd5b61077b826106b6565b9392505050565b634e487b7160e01b600052601160045260246000fd5b60006001600160481b03838116908316818110156107b8576107b8610782565b039392505050565b60006001600160ff1b03818413828413808216868404861116156107e6576107e6610782565b600160ff1b600087128281168783058912161561080557610805610782565b6000871292508782058712848416161561082157610821610782565b8785058712818416161561083757610837610782565b505050929093029392505050565b634e487b7160e01b600052601260045260246000fd5b60008261086a5761086a610845565b600160ff1b82146000198414161561088457610884610782565b500590565b60008083128015600160ff1b8501841216156108a7576108a7610782565b6001600160ff1b03840183138116156108c2576108c2610782565b50500390565b600080821280156001600160ff1b03849003851316156108ea576108ea610782565b600160ff1b839003841281161561090357610903610782565b50500190565b6000601682810b9084900b6001600160b71b038382138484138082168484048611161561093857610938610782565b6001600160b71b0319600085128281168783058712161561095b5761095b610782565b6000871292508582058712848416161561097757610977610782565b8585058712818416161561098d5761098d610782565b5050509290910295945050505050565b60006001600160b81b03828116848216811515828404821116156109c3576109c3610782565b02949350505050565b60006001600160b81b03838116806109e6576109e6610845565b92169190910492915050565b6000816000190483118215151615610a0c57610a0c610782565b500290565b600082610a2057610a20610845565b500490565b600060208284031215610a3757600080fd5b505191905056fea2646970667358221220d285086e6f155361e6f84cd239727144d7679378137f6578431df55b87f29c0364736f6c63430008090033",
  "devdoc": {
    "errors": {
      "InvalidBound(uint184)": [
        {
          "params": {
            "upperBound": "The upper price that the LSP will operate within."
          }
        }
      ],
      "InvalidCap(uint72)": [
        {
          "params": {
            "pctLongCap": "The cap on the percentage that can be allocated to the long token - enforced for improving MM on v2 AMMs for both L&S tokens."
          }
        }
      ],
      "InvalidInitialPrice(uint184)": [
        {
          "params": {
            "initialPrice": "The price of the asset at LSP deployment, used to calculate returns."
          }
        }
      ],
      "InvalidLSPAddress(address)": [
        {
          "params": {
            "longShortPair": "The address of the LSP contract."
          }
        }
      ],
      "InvalidLeverage(uint72)": [
        {
          "params": {
            "leverageFactor": "The amount of leverage you want to apply to the asset return."
          }
        }
      ]
    },
    "kind": "dev",
    "methods": {
      "percentageLongCollateralAtExpiry(int256)": {
        "params": {
          "expiryPrice": "The price from the optimistic oracle for the LSP price identifier."
        },
        "returns": {
          "_0": "expiryPercentLong to indicate how much collateral should be sent between long and short tokens."
        }
      },
      "setLongShortPairParameters(address,uint184,uint72,uint184,uint72)": {
        "details": "Note:  a) Any address can set these parameters  b) For safety, parameters should be set before depositing any synthetic tokens in a liquidity pool.  c) The parameters are set for the LSP contract address  d) Parameters can only be set once to prevent the deployer from changing the parameters after the fact.  e) upperBound can't be zero.  f) pctLongCap can't be greater than or equal to 1 ether (100%).  g) longShortPair must expose an expirationTimestamp method to validate it is correctly deployed.",
        "params": {
          "initialPrice": "The price of the asset at LSP deployment, used to calculate returns.",
          "leverageFactor": "The amount of leverage you want to apply to the asset return.",
          "longShortPair": "The address of the LSP contract.",
          "pctLongCap": "The cap on the percentage that can be allocated to the long token - enforced for improving MM on v2 AMMs for both L&S tokens.",
          "upperBound": "The upper price that the LSP will operate within."
        }
      }
    },
    "title": "Linear Long Short Pair Financial Product Library.",
    "version": 1
  },
  "userdoc": {
    "errors": {
      "InvalidBound(uint184)": [
        {
          "notice": "`upperBound` has to be greater than zero."
        }
      ],
      "InvalidCap(uint72)": [
        {
          "notice": "`pctLongCap` has to be less than 1 ether."
        }
      ],
      "InvalidInitialPrice(uint184)": [
        {
          "notice": "`initialPrice` has to be greater than zero."
        }
      ],
      "InvalidLSPAddress(address)": [
        {
          "notice": "`longShortPair` is not a valid LSP address."
        }
      ],
      "InvalidLeverage(uint72)": [
        {
          "notice": "`leverageFactor` has to be greater than 0."
        }
      ],
      "ParametersNotSet()": [
        {
          "notice": "Parameters not set for calling LSP."
        }
      ],
      "ParametersSet()": [
        {
          "notice": "Parameters already set for calling LSP."
        }
      ]
    },
    "kind": "user",
    "methods": {
      "percentageLongCollateralAtExpiry(int256)": {
        "notice": "Returns a number between 0 and 1e18 to indicate how much collateral each long and short token is entitled to per collateralPerPair."
      },
      "setLongShortPairParameters(address,uint184,uint72,uint184,uint72)": {
        "notice": "Enables any address to set the parameters for an associated financial product."
      }
    },
    "notice": "Adds settlement logic to modify the linearLSP to allow for leveraged LSPs. Also includes a capped percentage payable to the long (& short) token to make market making both the long and short tokens easier in a v2 style AMM.",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 2013,
        "contract": "contracts/LeveragedReserveLSPL.sol:LeveragedReserveLSPL",
        "label": "_notEntered",
        "offset": 0,
        "slot": "0",
        "type": "t_bool"
      },
      {
        "astId": 2752,
        "contract": "contracts/LeveragedReserveLSPL.sol:LeveragedReserveLSPL",
        "label": "longShortPairParameters",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_address,t_struct(LeveragedReserveLongShortPairParameters)2747_storage)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_mapping(t_address,t_struct(LeveragedReserveLongShortPairParameters)2747_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => struct LeveragedReserveLSPL.LeveragedReserveLongShortPairParameters)",
        "numberOfBytes": "32",
        "value": "t_struct(LeveragedReserveLongShortPairParameters)2747_storage"
      },
      "t_struct(LeveragedReserveLongShortPairParameters)2747_storage": {
        "encoding": "inplace",
        "label": "struct LeveragedReserveLSPL.LeveragedReserveLongShortPairParameters",
        "members": [
          {
            "astId": 2740,
            "contract": "contracts/LeveragedReserveLSPL.sol:LeveragedReserveLSPL",
            "label": "upperBound",
            "offset": 0,
            "slot": "0",
            "type": "t_uint184"
          },
          {
            "astId": 2742,
            "contract": "contracts/LeveragedReserveLSPL.sol:LeveragedReserveLSPL",
            "label": "pctLongCap",
            "offset": 23,
            "slot": "0",
            "type": "t_uint72"
          },
          {
            "astId": 2744,
            "contract": "contracts/LeveragedReserveLSPL.sol:LeveragedReserveLSPL",
            "label": "initialPrice",
            "offset": 0,
            "slot": "1",
            "type": "t_uint184"
          },
          {
            "astId": 2746,
            "contract": "contracts/LeveragedReserveLSPL.sol:LeveragedReserveLSPL",
            "label": "leverageFactor",
            "offset": 23,
            "slot": "1",
            "type": "t_uint72"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_uint184": {
        "encoding": "inplace",
        "label": "uint184",
        "numberOfBytes": "23"
      },
      "t_uint72": {
        "encoding": "inplace",
        "label": "uint72",
        "numberOfBytes": "9"
      }
    }
  }
}