{
  "address": "0x000000004113f60d8e84bB41C5F5a2eC825cEd1B",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "upperBound",
          "type": "uint256"
        }
      ],
      "name": "InvalidBound",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "pctLongCap",
          "type": "uint256"
        }
      ],
      "name": "InvalidCap",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "longShortPair",
          "type": "address"
        }
      ],
      "name": "InvalidLSPAddress",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ParametersNotSet",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ParametersSet",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "longShortPairParameters",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "upperBound",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "pctLongCap",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "int256",
          "name": "expiryPrice",
          "type": "int256"
        }
      ],
      "name": "percentageLongCollateralAtExpiry",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "longShortPair",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "upperBound",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "pctLongCap",
          "type": "uint256"
        }
      ],
      "name": "setLongShortPairParameters",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0xe4f5a58c80236541b8b014443c75932728c6d26a5639a6d56fe1bb43335fe140",
  "receipt": {
    "to": null,
    "from": "0x655888b79E322f4A7193F50a4eb304a5a4F29183",
    "contractAddress": "0x000000004113f60d8e84bB41C5F5a2eC825cEd1B",
    "transactionIndex": 67,
    "gasUsed": "357352",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000008000000000000000000000000000000000000000000000040000000000800000000000400000000100000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000002000000000000000000000000200000000000000000000000000000000000000000000000000000000000004000000000200000000001000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000100000",
    "blockHash": "0x8084c721cb27706d8e97a89a2aabfca0a4c6c05df73bb6c160f998ccb976d7d1",
    "transactionHash": "0xe4f5a58c80236541b8b014443c75932728c6d26a5639a6d56fe1bb43335fe140",
    "logs": [
      {
        "transactionIndex": 67,
        "blockNumber": 21694807,
        "transactionHash": "0xe4f5a58c80236541b8b014443c75932728c6d26a5639a6d56fe1bb43335fe140",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x000000000000000000000000655888b79e322f4a7193f50a4eb304a5a4f29183",
          "0x0000000000000000000000007c7379531b2aee82e4ca06d4175d13b9cbeafd49"
        ],
        "data": "0x0000000000000000000000000000000000000000000000000026164ae297e00000000000000000000000000000000000000000000000000014d1120d7b160000000000000000000000000000000000000000000000003ed7742458c275e273c800000000000000000000000000000000000000000000000014aafbc2987e2000000000000000000000000000000000000000000000003ed7744a6f0d587a53c8",
        "logIndex": 847,
        "blockHash": "0x8084c721cb27706d8e97a89a2aabfca0a4c6c05df73bb6c160f998ccb976d7d1"
      }
    ],
    "blockNumber": 21694807,
    "cumulativeGasUsed": "17109459",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "solcInputHash": "aaf21535b65fe2dfc1d522cd60d041d6",
  "metadata": "{\"compiler\":{\"version\":\"0.8.9+commit.e5eed63a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"upperBound\",\"type\":\"uint256\"}],\"name\":\"InvalidBound\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pctLongCap\",\"type\":\"uint256\"}],\"name\":\"InvalidCap\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"longShortPair\",\"type\":\"address\"}],\"name\":\"InvalidLSPAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ParametersNotSet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ParametersSet\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"longShortPairParameters\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"upperBound\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pctLongCap\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"expiryPrice\",\"type\":\"int256\"}],\"name\":\"percentageLongCollateralAtExpiry\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"longShortPair\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"upperBound\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pctLongCap\",\"type\":\"uint256\"}],\"name\":\"setLongShortPairParameters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"InvalidBound(uint256)\":[{\"params\":{\"upperBound\":\"The upper price that the LSP will operate within.\"}}],\"InvalidCap(uint256)\":[{\"params\":{\"pctLongCap\":\"The cap on the percentage that can be allocated to the long token - enforced for improving MM on v2 AMMs for both L&S tokens.\"}}],\"InvalidLSPAddress(address)\":[{\"params\":{\"longShortPair\":\"The address of the LSP contract.\"}}]},\"kind\":\"dev\",\"methods\":{\"percentageLongCollateralAtExpiry(int256)\":{\"params\":{\"expiryPrice\":\"The price from the optimistic oracle for the LSP price identifier.\"},\"returns\":{\"_0\":\"expiryPercentLong to indicate how much collateral should be sent between long and short tokens.\"}},\"setLongShortPairParameters(address,uint256,uint256)\":{\"details\":\"Note: a) Any address can set these parameters b) existing LSP parameters for address not set. c) upperBound > 0. d) parameters can only be set once to prevent the deployer from changing the parameters after the fact. e) For safety, parameters should be set before depositing any synthetic tokens in a liquidity pool. f) longShortPair must expose an expirationTimestamp method to validate it is correctly deployed.\",\"params\":{\"longShortPair\":\"The address of the LSP contract.\",\"pctLongCap\":\"The cap on the percentage that can be allocated to the long token - enforced for improving MM on v2 AMMs for both L&S tokens.\",\"upperBound\":\"The upper price that the LSP will operate within.\"}}},\"title\":\"Linear Long Short Pair Financial Product Library.\",\"version\":1},\"userdoc\":{\"errors\":{\"InvalidBound(uint256)\":[{\"notice\":\"`upperBound` has to be greater than zero.\"}],\"InvalidCap(uint256)\":[{\"notice\":\"`pctLongCap` has to be less than 1 ether.\"}],\"InvalidLSPAddress(address)\":[{\"notice\":\"`longShortPair` is not a valid LSP address.\"}],\"ParametersNotSet()\":[{\"notice\":\"Parameters not set for calling LSP.\"}],\"ParametersSet()\":[{\"notice\":\"Parameters already set for calling LSP.\"}]},\"kind\":\"user\",\"methods\":{\"percentageLongCollateralAtExpiry(int256)\":{\"notice\":\"Returns a number between 0 and 1e18 to indicate how much collateral each long and short token is entitled to per collateralPerPair.\"},\"setLongShortPairParameters(address,uint256,uint256)\":{\"notice\":\"Enables any address to set the parameters for an associated financial product.\"}},\"notice\":\"Adds settlement logic to create linear LSPs that have a capped percentage payable to the long (& short) token to make market making both the long and short tokens easier in a v2 style AMM.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/ReserveLSPL.sol\":\"ReserveLSPL\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/utils/math/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x8666f020bd8fc9dc14f07e2ebc52b5f236ab4cdde7c77679b08cb2f94730043b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SignedSafeMath` is no longer needed starting with Solidity 0.8. The compiler\\n * now has built in overflow checking.\\n */\\nlibrary SignedSafeMath {\\n    /**\\n     * @dev Returns the multiplication of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(int256 a, int256 b) internal pure returns (int256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two signed integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(int256 a, int256 b) internal pure returns (int256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(int256 a, int256 b) internal pure returns (int256) {\\n        return a + b;\\n    }\\n}\\n\",\"keccak256\":\"0xd1ddc24b24f12a347093844dd645c3a96bcdce05d1f51b8650946ad404cb3c40\",\"license\":\"MIT\"},\"@uma/core/contracts/common/implementation/FixedPoint.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\\\";\\n\\n/**\\n * @title Library for fixed point arithmetic on uints\\n */\\nlibrary FixedPoint {\\n    using SafeMath for uint256;\\n    using SignedSafeMath for int256;\\n\\n    // Supports 18 decimals. E.g., 1e18 represents \\\"1\\\", 5e17 represents \\\"0.5\\\".\\n    // For unsigned values:\\n    //   This can represent a value up to (2^256 - 1)/10^18 = ~10^59. 10^59 will be stored internally as uint256 10^77.\\n    uint256 private constant FP_SCALING_FACTOR = 10**18;\\n\\n    // --------------------------------------- UNSIGNED -----------------------------------------------------------------------------\\n    struct Unsigned {\\n        uint256 rawValue;\\n    }\\n\\n    /**\\n     * @notice Constructs an `Unsigned` from an unscaled uint, e.g., `b=5` gets stored internally as `5*(10**18)`.\\n     * @param a uint to convert into a FixedPoint.\\n     * @return the converted FixedPoint.\\n     */\\n    function fromUnscaledUint(uint256 a) internal pure returns (Unsigned memory) {\\n        return Unsigned(a.mul(FP_SCALING_FACTOR));\\n    }\\n\\n    /**\\n     * @notice Whether `a` is equal to `b`.\\n     * @param a a FixedPoint.\\n     * @param b a uint256.\\n     * @return True if equal, or False.\\n     */\\n    function isEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\\n        return a.rawValue == fromUnscaledUint(b).rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is equal to `b`.\\n     * @param a a FixedPoint.\\n     * @param b a FixedPoint.\\n     * @return True if equal, or False.\\n     */\\n    function isEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\\n        return a.rawValue == b.rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is greater than `b`.\\n     * @param a a FixedPoint.\\n     * @param b a FixedPoint.\\n     * @return True if `a > b`, or False.\\n     */\\n    function isGreaterThan(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\\n        return a.rawValue > b.rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is greater than `b`.\\n     * @param a a FixedPoint.\\n     * @param b a uint256.\\n     * @return True if `a > b`, or False.\\n     */\\n    function isGreaterThan(Unsigned memory a, uint256 b) internal pure returns (bool) {\\n        return a.rawValue > fromUnscaledUint(b).rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is greater than `b`.\\n     * @param a a uint256.\\n     * @param b a FixedPoint.\\n     * @return True if `a > b`, or False.\\n     */\\n    function isGreaterThan(uint256 a, Unsigned memory b) internal pure returns (bool) {\\n        return fromUnscaledUint(a).rawValue > b.rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is greater than or equal to `b`.\\n     * @param a a FixedPoint.\\n     * @param b a FixedPoint.\\n     * @return True if `a >= b`, or False.\\n     */\\n    function isGreaterThanOrEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\\n        return a.rawValue >= b.rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is greater than or equal to `b`.\\n     * @param a a FixedPoint.\\n     * @param b a uint256.\\n     * @return True if `a >= b`, or False.\\n     */\\n    function isGreaterThanOrEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\\n        return a.rawValue >= fromUnscaledUint(b).rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is greater than or equal to `b`.\\n     * @param a a uint256.\\n     * @param b a FixedPoint.\\n     * @return True if `a >= b`, or False.\\n     */\\n    function isGreaterThanOrEqual(uint256 a, Unsigned memory b) internal pure returns (bool) {\\n        return fromUnscaledUint(a).rawValue >= b.rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is less than `b`.\\n     * @param a a FixedPoint.\\n     * @param b a FixedPoint.\\n     * @return True if `a < b`, or False.\\n     */\\n    function isLessThan(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\\n        return a.rawValue < b.rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is less than `b`.\\n     * @param a a FixedPoint.\\n     * @param b a uint256.\\n     * @return True if `a < b`, or False.\\n     */\\n    function isLessThan(Unsigned memory a, uint256 b) internal pure returns (bool) {\\n        return a.rawValue < fromUnscaledUint(b).rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is less than `b`.\\n     * @param a a uint256.\\n     * @param b a FixedPoint.\\n     * @return True if `a < b`, or False.\\n     */\\n    function isLessThan(uint256 a, Unsigned memory b) internal pure returns (bool) {\\n        return fromUnscaledUint(a).rawValue < b.rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is less than or equal to `b`.\\n     * @param a a FixedPoint.\\n     * @param b a FixedPoint.\\n     * @return True if `a <= b`, or False.\\n     */\\n    function isLessThanOrEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\\n        return a.rawValue <= b.rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is less than or equal to `b`.\\n     * @param a a FixedPoint.\\n     * @param b a uint256.\\n     * @return True if `a <= b`, or False.\\n     */\\n    function isLessThanOrEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\\n        return a.rawValue <= fromUnscaledUint(b).rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is less than or equal to `b`.\\n     * @param a a uint256.\\n     * @param b a FixedPoint.\\n     * @return True if `a <= b`, or False.\\n     */\\n    function isLessThanOrEqual(uint256 a, Unsigned memory b) internal pure returns (bool) {\\n        return fromUnscaledUint(a).rawValue <= b.rawValue;\\n    }\\n\\n    /**\\n     * @notice The minimum of `a` and `b`.\\n     * @param a a FixedPoint.\\n     * @param b a FixedPoint.\\n     * @return the minimum of `a` and `b`.\\n     */\\n    function min(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\\n        return a.rawValue < b.rawValue ? a : b;\\n    }\\n\\n    /**\\n     * @notice The maximum of `a` and `b`.\\n     * @param a a FixedPoint.\\n     * @param b a FixedPoint.\\n     * @return the maximum of `a` and `b`.\\n     */\\n    function max(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\\n        return a.rawValue > b.rawValue ? a : b;\\n    }\\n\\n    /**\\n     * @notice Adds two `Unsigned`s, reverting on overflow.\\n     * @param a a FixedPoint.\\n     * @param b a FixedPoint.\\n     * @return the sum of `a` and `b`.\\n     */\\n    function add(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\\n        return Unsigned(a.rawValue.add(b.rawValue));\\n    }\\n\\n    /**\\n     * @notice Adds an `Unsigned` to an unscaled uint, reverting on overflow.\\n     * @param a a FixedPoint.\\n     * @param b a uint256.\\n     * @return the sum of `a` and `b`.\\n     */\\n    function add(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\\n        return add(a, fromUnscaledUint(b));\\n    }\\n\\n    /**\\n     * @notice Subtracts two `Unsigned`s, reverting on overflow.\\n     * @param a a FixedPoint.\\n     * @param b a FixedPoint.\\n     * @return the difference of `a` and `b`.\\n     */\\n    function sub(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\\n        return Unsigned(a.rawValue.sub(b.rawValue));\\n    }\\n\\n    /**\\n     * @notice Subtracts an unscaled uint256 from an `Unsigned`, reverting on overflow.\\n     * @param a a FixedPoint.\\n     * @param b a uint256.\\n     * @return the difference of `a` and `b`.\\n     */\\n    function sub(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\\n        return sub(a, fromUnscaledUint(b));\\n    }\\n\\n    /**\\n     * @notice Subtracts an `Unsigned` from an unscaled uint256, reverting on overflow.\\n     * @param a a uint256.\\n     * @param b a FixedPoint.\\n     * @return the difference of `a` and `b`.\\n     */\\n    function sub(uint256 a, Unsigned memory b) internal pure returns (Unsigned memory) {\\n        return sub(fromUnscaledUint(a), b);\\n    }\\n\\n    /**\\n     * @notice Multiplies two `Unsigned`s, reverting on overflow.\\n     * @dev This will \\\"floor\\\" the product.\\n     * @param a a FixedPoint.\\n     * @param b a FixedPoint.\\n     * @return the product of `a` and `b`.\\n     */\\n    function mul(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\\n        // There are two caveats with this computation:\\n        // 1. Max output for the represented number is ~10^41, otherwise an intermediate value overflows. 10^41 is\\n        // stored internally as a uint256 ~10^59.\\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 1.4 * 2e-18 = 2.8e-18, which\\n        // would round to 3, but this computation produces the result 2.\\n        // No need to use SafeMath because FP_SCALING_FACTOR != 0.\\n        return Unsigned(a.rawValue.mul(b.rawValue) / FP_SCALING_FACTOR);\\n    }\\n\\n    /**\\n     * @notice Multiplies an `Unsigned` and an unscaled uint256, reverting on overflow.\\n     * @dev This will \\\"floor\\\" the product.\\n     * @param a a FixedPoint.\\n     * @param b a uint256.\\n     * @return the product of `a` and `b`.\\n     */\\n    function mul(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\\n        return Unsigned(a.rawValue.mul(b));\\n    }\\n\\n    /**\\n     * @notice Multiplies two `Unsigned`s and \\\"ceil's\\\" the product, reverting on overflow.\\n     * @param a a FixedPoint.\\n     * @param b a FixedPoint.\\n     * @return the product of `a` and `b`.\\n     */\\n    function mulCeil(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\\n        uint256 mulRaw = a.rawValue.mul(b.rawValue);\\n        uint256 mulFloor = mulRaw / FP_SCALING_FACTOR;\\n        uint256 mod = mulRaw.mod(FP_SCALING_FACTOR);\\n        if (mod != 0) {\\n            return Unsigned(mulFloor.add(1));\\n        } else {\\n            return Unsigned(mulFloor);\\n        }\\n    }\\n\\n    /**\\n     * @notice Multiplies an `Unsigned` and an unscaled uint256 and \\\"ceil's\\\" the product, reverting on overflow.\\n     * @param a a FixedPoint.\\n     * @param b a FixedPoint.\\n     * @return the product of `a` and `b`.\\n     */\\n    function mulCeil(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\\n        // Since b is an uint, there is no risk of truncation and we can just mul it normally\\n        return Unsigned(a.rawValue.mul(b));\\n    }\\n\\n    /**\\n     * @notice Divides one `Unsigned` by an `Unsigned`, reverting on overflow or division by 0.\\n     * @dev This will \\\"floor\\\" the quotient.\\n     * @param a a FixedPoint numerator.\\n     * @param b a FixedPoint denominator.\\n     * @return the quotient of `a` divided by `b`.\\n     */\\n    function div(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\\n        // There are two caveats with this computation:\\n        // 1. Max value for the number dividend `a` represents is ~10^41, otherwise an intermediate value overflows.\\n        // 10^41 is stored internally as a uint256 10^59.\\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 2 / 3 = 0.6 repeating, which\\n        // would round to 0.666666666666666667, but this computation produces the result 0.666666666666666666.\\n        return Unsigned(a.rawValue.mul(FP_SCALING_FACTOR).div(b.rawValue));\\n    }\\n\\n    /**\\n     * @notice Divides one `Unsigned` by an unscaled uint256, reverting on overflow or division by 0.\\n     * @dev This will \\\"floor\\\" the quotient.\\n     * @param a a FixedPoint numerator.\\n     * @param b a uint256 denominator.\\n     * @return the quotient of `a` divided by `b`.\\n     */\\n    function div(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\\n        return Unsigned(a.rawValue.div(b));\\n    }\\n\\n    /**\\n     * @notice Divides one unscaled uint256 by an `Unsigned`, reverting on overflow or division by 0.\\n     * @dev This will \\\"floor\\\" the quotient.\\n     * @param a a uint256 numerator.\\n     * @param b a FixedPoint denominator.\\n     * @return the quotient of `a` divided by `b`.\\n     */\\n    function div(uint256 a, Unsigned memory b) internal pure returns (Unsigned memory) {\\n        return div(fromUnscaledUint(a), b);\\n    }\\n\\n    /**\\n     * @notice Divides one `Unsigned` by an `Unsigned` and \\\"ceil's\\\" the quotient, reverting on overflow or division by 0.\\n     * @param a a FixedPoint numerator.\\n     * @param b a FixedPoint denominator.\\n     * @return the quotient of `a` divided by `b`.\\n     */\\n    function divCeil(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\\n        uint256 aScaled = a.rawValue.mul(FP_SCALING_FACTOR);\\n        uint256 divFloor = aScaled.div(b.rawValue);\\n        uint256 mod = aScaled.mod(b.rawValue);\\n        if (mod != 0) {\\n            return Unsigned(divFloor.add(1));\\n        } else {\\n            return Unsigned(divFloor);\\n        }\\n    }\\n\\n    /**\\n     * @notice Divides one `Unsigned` by an unscaled uint256 and \\\"ceil's\\\" the quotient, reverting on overflow or division by 0.\\n     * @param a a FixedPoint numerator.\\n     * @param b a uint256 denominator.\\n     * @return the quotient of `a` divided by `b`.\\n     */\\n    function divCeil(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\\n        // Because it is possible that a quotient gets truncated, we can't just call \\\"Unsigned(a.rawValue.div(b))\\\"\\n        // similarly to mulCeil with a uint256 as the second parameter. Therefore we need to convert b into an Unsigned.\\n        // This creates the possibility of overflow if b is very large.\\n        return divCeil(a, fromUnscaledUint(b));\\n    }\\n\\n    /**\\n     * @notice Raises an `Unsigned` to the power of an unscaled uint256, reverting on overflow. E.g., `b=2` squares `a`.\\n     * @dev This will \\\"floor\\\" the result.\\n     * @param a a FixedPoint numerator.\\n     * @param b a uint256 denominator.\\n     * @return output is `a` to the power of `b`.\\n     */\\n    function pow(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory output) {\\n        output = fromUnscaledUint(1);\\n        for (uint256 i = 0; i < b; i = i.add(1)) {\\n            output = mul(output, a);\\n        }\\n    }\\n\\n    // ------------------------------------------------- SIGNED -------------------------------------------------------------\\n    // Supports 18 decimals. E.g., 1e18 represents \\\"1\\\", 5e17 represents \\\"0.5\\\".\\n    // For signed values:\\n    //   This can represent a value up (or down) to +-(2^255 - 1)/10^18 = ~10^58. 10^58 will be stored internally as int256 10^76.\\n    int256 private constant SFP_SCALING_FACTOR = 10**18;\\n\\n    struct Signed {\\n        int256 rawValue;\\n    }\\n\\n    function fromSigned(Signed memory a) internal pure returns (Unsigned memory) {\\n        require(a.rawValue >= 0, \\\"Negative value provided\\\");\\n        return Unsigned(uint256(a.rawValue));\\n    }\\n\\n    function fromUnsigned(Unsigned memory a) internal pure returns (Signed memory) {\\n        require(a.rawValue <= uint256(type(int256).max), \\\"Unsigned too large\\\");\\n        return Signed(int256(a.rawValue));\\n    }\\n\\n    /**\\n     * @notice Constructs a `Signed` from an unscaled int, e.g., `b=5` gets stored internally as `5*(10**18)`.\\n     * @param a int to convert into a FixedPoint.Signed.\\n     * @return the converted FixedPoint.Signed.\\n     */\\n    function fromUnscaledInt(int256 a) internal pure returns (Signed memory) {\\n        return Signed(a.mul(SFP_SCALING_FACTOR));\\n    }\\n\\n    /**\\n     * @notice Whether `a` is equal to `b`.\\n     * @param a a FixedPoint.Signed.\\n     * @param b a int256.\\n     * @return True if equal, or False.\\n     */\\n    function isEqual(Signed memory a, int256 b) internal pure returns (bool) {\\n        return a.rawValue == fromUnscaledInt(b).rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is equal to `b`.\\n     * @param a a FixedPoint.Signed.\\n     * @param b a FixedPoint.Signed.\\n     * @return True if equal, or False.\\n     */\\n    function isEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\\n        return a.rawValue == b.rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is greater than `b`.\\n     * @param a a FixedPoint.Signed.\\n     * @param b a FixedPoint.Signed.\\n     * @return True if `a > b`, or False.\\n     */\\n    function isGreaterThan(Signed memory a, Signed memory b) internal pure returns (bool) {\\n        return a.rawValue > b.rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is greater than `b`.\\n     * @param a a FixedPoint.Signed.\\n     * @param b an int256.\\n     * @return True if `a > b`, or False.\\n     */\\n    function isGreaterThan(Signed memory a, int256 b) internal pure returns (bool) {\\n        return a.rawValue > fromUnscaledInt(b).rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is greater than `b`.\\n     * @param a an int256.\\n     * @param b a FixedPoint.Signed.\\n     * @return True if `a > b`, or False.\\n     */\\n    function isGreaterThan(int256 a, Signed memory b) internal pure returns (bool) {\\n        return fromUnscaledInt(a).rawValue > b.rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is greater than or equal to `b`.\\n     * @param a a FixedPoint.Signed.\\n     * @param b a FixedPoint.Signed.\\n     * @return True if `a >= b`, or False.\\n     */\\n    function isGreaterThanOrEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\\n        return a.rawValue >= b.rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is greater than or equal to `b`.\\n     * @param a a FixedPoint.Signed.\\n     * @param b an int256.\\n     * @return True if `a >= b`, or False.\\n     */\\n    function isGreaterThanOrEqual(Signed memory a, int256 b) internal pure returns (bool) {\\n        return a.rawValue >= fromUnscaledInt(b).rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is greater than or equal to `b`.\\n     * @param a an int256.\\n     * @param b a FixedPoint.Signed.\\n     * @return True if `a >= b`, or False.\\n     */\\n    function isGreaterThanOrEqual(int256 a, Signed memory b) internal pure returns (bool) {\\n        return fromUnscaledInt(a).rawValue >= b.rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is less than `b`.\\n     * @param a a FixedPoint.Signed.\\n     * @param b a FixedPoint.Signed.\\n     * @return True if `a < b`, or False.\\n     */\\n    function isLessThan(Signed memory a, Signed memory b) internal pure returns (bool) {\\n        return a.rawValue < b.rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is less than `b`.\\n     * @param a a FixedPoint.Signed.\\n     * @param b an int256.\\n     * @return True if `a < b`, or False.\\n     */\\n    function isLessThan(Signed memory a, int256 b) internal pure returns (bool) {\\n        return a.rawValue < fromUnscaledInt(b).rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is less than `b`.\\n     * @param a an int256.\\n     * @param b a FixedPoint.Signed.\\n     * @return True if `a < b`, or False.\\n     */\\n    function isLessThan(int256 a, Signed memory b) internal pure returns (bool) {\\n        return fromUnscaledInt(a).rawValue < b.rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is less than or equal to `b`.\\n     * @param a a FixedPoint.Signed.\\n     * @param b a FixedPoint.Signed.\\n     * @return True if `a <= b`, or False.\\n     */\\n    function isLessThanOrEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\\n        return a.rawValue <= b.rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is less than or equal to `b`.\\n     * @param a a FixedPoint.Signed.\\n     * @param b an int256.\\n     * @return True if `a <= b`, or False.\\n     */\\n    function isLessThanOrEqual(Signed memory a, int256 b) internal pure returns (bool) {\\n        return a.rawValue <= fromUnscaledInt(b).rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is less than or equal to `b`.\\n     * @param a an int256.\\n     * @param b a FixedPoint.Signed.\\n     * @return True if `a <= b`, or False.\\n     */\\n    function isLessThanOrEqual(int256 a, Signed memory b) internal pure returns (bool) {\\n        return fromUnscaledInt(a).rawValue <= b.rawValue;\\n    }\\n\\n    /**\\n     * @notice The minimum of `a` and `b`.\\n     * @param a a FixedPoint.Signed.\\n     * @param b a FixedPoint.Signed.\\n     * @return the minimum of `a` and `b`.\\n     */\\n    function min(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\\n        return a.rawValue < b.rawValue ? a : b;\\n    }\\n\\n    /**\\n     * @notice The maximum of `a` and `b`.\\n     * @param a a FixedPoint.Signed.\\n     * @param b a FixedPoint.Signed.\\n     * @return the maximum of `a` and `b`.\\n     */\\n    function max(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\\n        return a.rawValue > b.rawValue ? a : b;\\n    }\\n\\n    /**\\n     * @notice Adds two `Signed`s, reverting on overflow.\\n     * @param a a FixedPoint.Signed.\\n     * @param b a FixedPoint.Signed.\\n     * @return the sum of `a` and `b`.\\n     */\\n    function add(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\\n        return Signed(a.rawValue.add(b.rawValue));\\n    }\\n\\n    /**\\n     * @notice Adds an `Signed` to an unscaled int, reverting on overflow.\\n     * @param a a FixedPoint.Signed.\\n     * @param b an int256.\\n     * @return the sum of `a` and `b`.\\n     */\\n    function add(Signed memory a, int256 b) internal pure returns (Signed memory) {\\n        return add(a, fromUnscaledInt(b));\\n    }\\n\\n    /**\\n     * @notice Subtracts two `Signed`s, reverting on overflow.\\n     * @param a a FixedPoint.Signed.\\n     * @param b a FixedPoint.Signed.\\n     * @return the difference of `a` and `b`.\\n     */\\n    function sub(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\\n        return Signed(a.rawValue.sub(b.rawValue));\\n    }\\n\\n    /**\\n     * @notice Subtracts an unscaled int256 from an `Signed`, reverting on overflow.\\n     * @param a a FixedPoint.Signed.\\n     * @param b an int256.\\n     * @return the difference of `a` and `b`.\\n     */\\n    function sub(Signed memory a, int256 b) internal pure returns (Signed memory) {\\n        return sub(a, fromUnscaledInt(b));\\n    }\\n\\n    /**\\n     * @notice Subtracts an `Signed` from an unscaled int256, reverting on overflow.\\n     * @param a an int256.\\n     * @param b a FixedPoint.Signed.\\n     * @return the difference of `a` and `b`.\\n     */\\n    function sub(int256 a, Signed memory b) internal pure returns (Signed memory) {\\n        return sub(fromUnscaledInt(a), b);\\n    }\\n\\n    /**\\n     * @notice Multiplies two `Signed`s, reverting on overflow.\\n     * @dev This will \\\"floor\\\" the product.\\n     * @param a a FixedPoint.Signed.\\n     * @param b a FixedPoint.Signed.\\n     * @return the product of `a` and `b`.\\n     */\\n    function mul(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\\n        // There are two caveats with this computation:\\n        // 1. Max output for the represented number is ~10^41, otherwise an intermediate value overflows. 10^41 is\\n        // stored internally as an int256 ~10^59.\\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 1.4 * 2e-18 = 2.8e-18, which\\n        // would round to 3, but this computation produces the result 2.\\n        // No need to use SafeMath because SFP_SCALING_FACTOR != 0.\\n        return Signed(a.rawValue.mul(b.rawValue) / SFP_SCALING_FACTOR);\\n    }\\n\\n    /**\\n     * @notice Multiplies an `Signed` and an unscaled int256, reverting on overflow.\\n     * @dev This will \\\"floor\\\" the product.\\n     * @param a a FixedPoint.Signed.\\n     * @param b an int256.\\n     * @return the product of `a` and `b`.\\n     */\\n    function mul(Signed memory a, int256 b) internal pure returns (Signed memory) {\\n        return Signed(a.rawValue.mul(b));\\n    }\\n\\n    /**\\n     * @notice Multiplies two `Signed`s and \\\"ceil's\\\" the product, reverting on overflow.\\n     * @param a a FixedPoint.Signed.\\n     * @param b a FixedPoint.Signed.\\n     * @return the product of `a` and `b`.\\n     */\\n    function mulAwayFromZero(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\\n        int256 mulRaw = a.rawValue.mul(b.rawValue);\\n        int256 mulTowardsZero = mulRaw / SFP_SCALING_FACTOR;\\n        // Manual mod because SignedSafeMath doesn't support it.\\n        int256 mod = mulRaw % SFP_SCALING_FACTOR;\\n        if (mod != 0) {\\n            bool isResultPositive = isLessThan(a, 0) == isLessThan(b, 0);\\n            int256 valueToAdd = isResultPositive ? int256(1) : int256(-1);\\n            return Signed(mulTowardsZero.add(valueToAdd));\\n        } else {\\n            return Signed(mulTowardsZero);\\n        }\\n    }\\n\\n    /**\\n     * @notice Multiplies an `Signed` and an unscaled int256 and \\\"ceil's\\\" the product, reverting on overflow.\\n     * @param a a FixedPoint.Signed.\\n     * @param b a FixedPoint.Signed.\\n     * @return the product of `a` and `b`.\\n     */\\n    function mulAwayFromZero(Signed memory a, int256 b) internal pure returns (Signed memory) {\\n        // Since b is an int, there is no risk of truncation and we can just mul it normally\\n        return Signed(a.rawValue.mul(b));\\n    }\\n\\n    /**\\n     * @notice Divides one `Signed` by an `Signed`, reverting on overflow or division by 0.\\n     * @dev This will \\\"floor\\\" the quotient.\\n     * @param a a FixedPoint numerator.\\n     * @param b a FixedPoint denominator.\\n     * @return the quotient of `a` divided by `b`.\\n     */\\n    function div(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\\n        // There are two caveats with this computation:\\n        // 1. Max value for the number dividend `a` represents is ~10^41, otherwise an intermediate value overflows.\\n        // 10^41 is stored internally as an int256 10^59.\\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 2 / 3 = 0.6 repeating, which\\n        // would round to 0.666666666666666667, but this computation produces the result 0.666666666666666666.\\n        return Signed(a.rawValue.mul(SFP_SCALING_FACTOR).div(b.rawValue));\\n    }\\n\\n    /**\\n     * @notice Divides one `Signed` by an unscaled int256, reverting on overflow or division by 0.\\n     * @dev This will \\\"floor\\\" the quotient.\\n     * @param a a FixedPoint numerator.\\n     * @param b an int256 denominator.\\n     * @return the quotient of `a` divided by `b`.\\n     */\\n    function div(Signed memory a, int256 b) internal pure returns (Signed memory) {\\n        return Signed(a.rawValue.div(b));\\n    }\\n\\n    /**\\n     * @notice Divides one unscaled int256 by an `Signed`, reverting on overflow or division by 0.\\n     * @dev This will \\\"floor\\\" the quotient.\\n     * @param a an int256 numerator.\\n     * @param b a FixedPoint denominator.\\n     * @return the quotient of `a` divided by `b`.\\n     */\\n    function div(int256 a, Signed memory b) internal pure returns (Signed memory) {\\n        return div(fromUnscaledInt(a), b);\\n    }\\n\\n    /**\\n     * @notice Divides one `Signed` by an `Signed` and \\\"ceil's\\\" the quotient, reverting on overflow or division by 0.\\n     * @param a a FixedPoint numerator.\\n     * @param b a FixedPoint denominator.\\n     * @return the quotient of `a` divided by `b`.\\n     */\\n    function divAwayFromZero(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\\n        int256 aScaled = a.rawValue.mul(SFP_SCALING_FACTOR);\\n        int256 divTowardsZero = aScaled.div(b.rawValue);\\n        // Manual mod because SignedSafeMath doesn't support it.\\n        int256 mod = aScaled % b.rawValue;\\n        if (mod != 0) {\\n            bool isResultPositive = isLessThan(a, 0) == isLessThan(b, 0);\\n            int256 valueToAdd = isResultPositive ? int256(1) : int256(-1);\\n            return Signed(divTowardsZero.add(valueToAdd));\\n        } else {\\n            return Signed(divTowardsZero);\\n        }\\n    }\\n\\n    /**\\n     * @notice Divides one `Signed` by an unscaled int256 and \\\"ceil's\\\" the quotient, reverting on overflow or division by 0.\\n     * @param a a FixedPoint numerator.\\n     * @param b an int256 denominator.\\n     * @return the quotient of `a` divided by `b`.\\n     */\\n    function divAwayFromZero(Signed memory a, int256 b) internal pure returns (Signed memory) {\\n        // Because it is possible that a quotient gets truncated, we can't just call \\\"Signed(a.rawValue.div(b))\\\"\\n        // similarly to mulCeil with an int256 as the second parameter. Therefore we need to convert b into an Signed.\\n        // This creates the possibility of overflow if b is very large.\\n        return divAwayFromZero(a, fromUnscaledInt(b));\\n    }\\n\\n    /**\\n     * @notice Raises an `Signed` to the power of an unscaled uint256, reverting on overflow. E.g., `b=2` squares `a`.\\n     * @dev This will \\\"floor\\\" the result.\\n     * @param a a FixedPoint.Signed.\\n     * @param b a uint256 (negative exponents are not allowed).\\n     * @return output is `a` to the power of `b`.\\n     */\\n    function pow(Signed memory a, uint256 b) internal pure returns (Signed memory output) {\\n        output = fromUnscaledInt(1);\\n        for (uint256 i = 0; i < b; i = i.add(1)) {\\n            output = mul(output, a);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x996b97cc4fa5da4064e3aee500edc6972485d59a9334ceec81155e2c2f484dae\",\"license\":\"AGPL-3.0-only\"},\"@uma/core/contracts/common/implementation/Lockable.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title A contract that provides modifiers to prevent reentrancy to state-changing and view-only methods. This contract\\n * is inspired by https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/ReentrancyGuard.sol\\n * and https://github.com/balancer-labs/balancer-core/blob/master/contracts/BPool.sol.\\n */\\ncontract Lockable {\\n    bool private _notEntered;\\n\\n    constructor() {\\n        // Storing an initial non-zero value makes deployment a bit more expensive, but in exchange the refund on every\\n        // call to nonReentrant will be lower in amount. Since refunds are capped to a percentage of the total\\n        // transaction's gas, it is best to keep them low in cases like this one, to increase the likelihood of the full\\n        // refund coming into effect.\\n        _notEntered = true;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant` function is not supported. It is possible to\\n     * prevent this from happening by making the `nonReentrant` function external, and making it call a `private`\\n     * function that does the actual state modification.\\n     */\\n    modifier nonReentrant() {\\n        _preEntranceCheck();\\n        _preEntranceSet();\\n        _;\\n        _postEntranceReset();\\n    }\\n\\n    /**\\n     * @dev Designed to prevent a view-only method from being re-entered during a call to a `nonReentrant()` state-changing method.\\n     */\\n    modifier nonReentrantView() {\\n        _preEntranceCheck();\\n        _;\\n    }\\n\\n    // Internal methods are used to avoid copying the require statement's bytecode to every `nonReentrant()` method.\\n    // On entry into a function, `_preEntranceCheck()` should always be called to check if the function is being\\n    // re-entered. Then, if the function modifies state, it should call `_postEntranceSet()`, perform its logic, and\\n    // then call `_postEntranceReset()`.\\n    // View-only methods can simply call `_preEntranceCheck()` to make sure that it is not being re-entered.\\n    function _preEntranceCheck() internal view {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_notEntered, \\\"ReentrancyGuard: reentrant call\\\");\\n    }\\n\\n    function _preEntranceSet() internal {\\n        // Any calls to nonReentrant after this point will fail\\n        _notEntered = false;\\n    }\\n\\n    function _postEntranceReset() internal {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _notEntered = true;\\n    }\\n}\\n\",\"keccak256\":\"0xcd34b3f83b61a096b53020749f327096d5cacd89c2393d947595afb934496ad4\",\"license\":\"AGPL-3.0-only\"},\"@uma/core/contracts/financial-templates/common/financial-product-libraries/long-short-pair-libraries/LongShortPairFinancialProductLibrary.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.0;\\nimport \\\"../../../../common/implementation/FixedPoint.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\n\\ninterface ExpiringContractInterface {\\n    function expirationTimestamp() external view returns (uint256);\\n}\\n\\nabstract contract LongShortPairFinancialProductLibrary {\\n    function percentageLongCollateralAtExpiry(int256 expiryPrice) public view virtual returns (uint256);\\n}\\n\",\"keccak256\":\"0x74229dc41c9be406f5b038f5e7e42403355110559e5f37ade5ed3d547020cfae\",\"license\":\"AGPL-3.0-only\"},\"contracts/ReserveLSPL.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.9;\\n\\nimport \\\"@uma/core/contracts/financial-templates/common/financial-product-libraries/long-short-pair-libraries/LongShortPairFinancialProductLibrary.sol\\\";\\nimport \\\"@uma/core/contracts/common/implementation/Lockable.sol\\\";\\n\\n/**\\n * @title Linear Long Short Pair Financial Product Library.\\n * @notice Adds settlement logic to create linear LSPs that have a capped percentage payable to the long (& short) token to\\n * make market making both the long and short tokens easier in a v2 style AMM.\\n */\\ncontract ReserveLSPL is LongShortPairFinancialProductLibrary, Lockable {\\n    struct ReserveLinearLongShortPairParameters {\\n        uint256 upperBound;\\n        uint256 pctLongCap;\\n    }\\n\\n    mapping(address => ReserveLinearLongShortPairParameters) public longShortPairParameters;\\n\\n    /// `longShortPair` is not a valid LSP address.\\n    /// @param longShortPair The address of the LSP contract.\\n    error InvalidLSPAddress(address longShortPair);\\n\\n    /// `upperBound` has to be greater than zero.\\n    /// @param upperBound The upper price that the LSP will operate within.\\n    error InvalidBound(uint256 upperBound);\\n\\n    /// `pctLongCap` has to be less than 1 ether.\\n    /// @param pctLongCap The cap on the percentage that can be allocated to the long token - enforced for improving MM on v2 AMMs for both L&S tokens.\\n    error InvalidCap(uint256 pctLongCap);\\n\\n    /// @notice Parameters already set for calling LSP.\\n    error ParametersSet();\\n\\n    /// @notice Parameters not set for calling LSP.\\n    error ParametersNotSet();\\n\\n    /**\\n     * @notice Enables any address to set the parameters for an associated financial product.\\n     * @param longShortPair The address of the LSP contract.\\n     * @param upperBound The upper price that the LSP will operate within.\\n     * @param pctLongCap The cap on the percentage that can be allocated to the long token - enforced for improving MM on v2 AMMs for both L&S tokens.\\n     * @dev Note:\\n     * a) Any address can set these parameters\\n     * b) existing LSP parameters for address not set.\\n     * c) upperBound > 0.\\n     * d) parameters can only be set once to prevent the deployer from changing the parameters after the fact.\\n     * e) For safety, parameters should be set before depositing any synthetic tokens in a liquidity pool.\\n     * f) longShortPair must expose an expirationTimestamp method to validate it is correctly deployed.\\n     */\\n    function setLongShortPairParameters(\\n        address longShortPair,\\n        uint256 upperBound,\\n        uint256 pctLongCap\\n    ) public nonReentrant {\\n        if (ExpiringContractInterface(longShortPair).expirationTimestamp() == 0)\\n            revert InvalidLSPAddress(longShortPair);\\n        // upperBound at 0 would cause a division by 0\\n        if (upperBound <= 0) revert InvalidBound(upperBound);\\n        if (pctLongCap >= 1 ether) revert InvalidCap(pctLongCap);\\n\\n        ReserveLinearLongShortPairParameters memory params = longShortPairParameters[longShortPair];\\n\\n        if (params.upperBound != 0) revert ParametersSet();\\n\\n        longShortPairParameters[longShortPair] = ReserveLinearLongShortPairParameters({\\n            upperBound: upperBound,\\n            pctLongCap: pctLongCap\\n        });\\n    }\\n\\n    /**\\n     * @notice Returns a number between 0 and 1e18 to indicate how much collateral each long and short token is entitled\\n     * to per collateralPerPair.\\n     * @param expiryPrice The price from the optimistic oracle for the LSP price identifier.\\n     * @return expiryPercentLong to indicate how much collateral should be sent between long and short tokens.\\n     */\\n    function percentageLongCollateralAtExpiry(int256 expiryPrice)\\n        public\\n        view\\n        override\\n        nonReentrantView\\n        returns (uint256)\\n    {\\n        ReserveLinearLongShortPairParameters memory params = longShortPairParameters[msg.sender];\\n        if (params.upperBound == 0) revert ParametersNotSet();\\n        uint256 positivePrice = expiryPrice < 0 ? 0 : uint256(expiryPrice);\\n        uint256 effectiveUpperBound = (params.upperBound * params.pctLongCap) / 1 ether;\\n        uint256 effectiveLowerBound = (params.upperBound * (1 ether - params.pctLongCap)) / 1 ether;\\n        if (positivePrice <= effectiveLowerBound) return (1 ether - params.pctLongCap);\\n        if (positivePrice >= effectiveUpperBound) return params.pctLongCap;\\n        return (positivePrice * 1 ether) / params.upperBound;\\n    }\\n}\\n\",\"keccak256\":\"0x5e536f48a87ea512c0733d97a84eda1a45dcdf2fa8f95b76d2aef65331ddf459\",\"license\":\"AGPL-3.0-only\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b506000805460ff1916600117905561051a8061002d6000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c80632da52361146100465780639299cbed1461006c57806392a98f53146100a8575b600080fd5b6100596100543660046103d8565b6100bd565b6040519081526020015b60405180910390f35b61009361007a366004610408565b6001602081905260009182526040909120805491015482565b60408051928352602083019190915201610063565b6100bb6100b636600461042a565b6101e4565b005b60006100c7610384565b33600090815260016020818152604092839020835180850190945280548085529201549083015261010b57604051636ba8dee360e01b815260040160405180910390fd5b600080841261011a578361011d565b60005b90506000670de0b6b3a76400008360200151846000015161013e9190610473565b6101489190610492565b90506000670de0b6b3a76400008460200151670de0b6b3a764000061016d91906104b4565b85516101799190610473565b6101839190610492565b90508083116101ad5760208401516101a390670de0b6b3a76400006104b4565b9695505050505050565b8183106101c1575050506020015192915050565b83516101d584670de0b6b3a7640000610473565b6101a39190610492565b919050565b6101ec610384565b6101fb6000805460ff19169055565b826001600160a01b0316639f43ddd26040518163ffffffff1660e01b815260040160206040518083038186803b15801561023457600080fd5b505afa158015610248573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061026c91906104cb565b6102995760405163d096610560e01b81526001600160a01b03841660048201526024015b60405180910390fd5b600082116102bd5760405163e71bc92d60e01b815260048101839052602401610290565b670de0b6b3a764000081106102e8576040516330c2ba0360e01b815260048101829052602401610290565b6001600160a01b03831660009081526001602081815260409283902083518085019094528054808552920154908301521561033657604051633190ad1960e01b815260040160405180910390fd5b5060408051808201825283815260208082018481526001600160a01b03871660009081526001928390529390932091518255915191015561037f6000805460ff19166001179055565b505050565b60005460ff166103d65760405162461bcd60e51b815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c006044820152606401610290565b565b6000602082840312156103ea57600080fd5b5035919050565b80356001600160a01b03811681146101df57600080fd5b60006020828403121561041a57600080fd5b610423826103f1565b9392505050565b60008060006060848603121561043f57600080fd5b610448846103f1565b95602085013595506040909401359392505050565b634e487b7160e01b600052601160045260246000fd5b600081600019048311821515161561048d5761048d61045d565b500290565b6000826104af57634e487b7160e01b600052601260045260246000fd5b500490565b6000828210156104c6576104c661045d565b500390565b6000602082840312156104dd57600080fd5b505191905056fea2646970667358221220ab3ce80de47a0a486a691d4566cd22a7d9aed85d5fd6193b512a2b4eccb4f4d564736f6c63430008090033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100415760003560e01c80632da52361146100465780639299cbed1461006c57806392a98f53146100a8575b600080fd5b6100596100543660046103d8565b6100bd565b6040519081526020015b60405180910390f35b61009361007a366004610408565b6001602081905260009182526040909120805491015482565b60408051928352602083019190915201610063565b6100bb6100b636600461042a565b6101e4565b005b60006100c7610384565b33600090815260016020818152604092839020835180850190945280548085529201549083015261010b57604051636ba8dee360e01b815260040160405180910390fd5b600080841261011a578361011d565b60005b90506000670de0b6b3a76400008360200151846000015161013e9190610473565b6101489190610492565b90506000670de0b6b3a76400008460200151670de0b6b3a764000061016d91906104b4565b85516101799190610473565b6101839190610492565b90508083116101ad5760208401516101a390670de0b6b3a76400006104b4565b9695505050505050565b8183106101c1575050506020015192915050565b83516101d584670de0b6b3a7640000610473565b6101a39190610492565b919050565b6101ec610384565b6101fb6000805460ff19169055565b826001600160a01b0316639f43ddd26040518163ffffffff1660e01b815260040160206040518083038186803b15801561023457600080fd5b505afa158015610248573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061026c91906104cb565b6102995760405163d096610560e01b81526001600160a01b03841660048201526024015b60405180910390fd5b600082116102bd5760405163e71bc92d60e01b815260048101839052602401610290565b670de0b6b3a764000081106102e8576040516330c2ba0360e01b815260048101829052602401610290565b6001600160a01b03831660009081526001602081815260409283902083518085019094528054808552920154908301521561033657604051633190ad1960e01b815260040160405180910390fd5b5060408051808201825283815260208082018481526001600160a01b03871660009081526001928390529390932091518255915191015561037f6000805460ff19166001179055565b505050565b60005460ff166103d65760405162461bcd60e51b815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c006044820152606401610290565b565b6000602082840312156103ea57600080fd5b5035919050565b80356001600160a01b03811681146101df57600080fd5b60006020828403121561041a57600080fd5b610423826103f1565b9392505050565b60008060006060848603121561043f57600080fd5b610448846103f1565b95602085013595506040909401359392505050565b634e487b7160e01b600052601160045260246000fd5b600081600019048311821515161561048d5761048d61045d565b500290565b6000826104af57634e487b7160e01b600052601260045260246000fd5b500490565b6000828210156104c6576104c661045d565b500390565b6000602082840312156104dd57600080fd5b505191905056fea2646970667358221220ab3ce80de47a0a486a691d4566cd22a7d9aed85d5fd6193b512a2b4eccb4f4d564736f6c63430008090033",
  "devdoc": {
    "errors": {
      "InvalidBound(uint256)": [
        {
          "params": {
            "upperBound": "The upper price that the LSP will operate within."
          }
        }
      ],
      "InvalidCap(uint256)": [
        {
          "params": {
            "pctLongCap": "The cap on the percentage that can be allocated to the long token - enforced for improving MM on v2 AMMs for both L&S tokens."
          }
        }
      ],
      "InvalidLSPAddress(address)": [
        {
          "params": {
            "longShortPair": "The address of the LSP contract."
          }
        }
      ]
    },
    "kind": "dev",
    "methods": {
      "percentageLongCollateralAtExpiry(int256)": {
        "params": {
          "expiryPrice": "The price from the optimistic oracle for the LSP price identifier."
        },
        "returns": {
          "_0": "expiryPercentLong to indicate how much collateral should be sent between long and short tokens."
        }
      },
      "setLongShortPairParameters(address,uint256,uint256)": {
        "details": "Note: a) Any address can set these parameters b) existing LSP parameters for address not set. c) upperBound > 0. d) parameters can only be set once to prevent the deployer from changing the parameters after the fact. e) For safety, parameters should be set before depositing any synthetic tokens in a liquidity pool. f) longShortPair must expose an expirationTimestamp method to validate it is correctly deployed.",
        "params": {
          "longShortPair": "The address of the LSP contract.",
          "pctLongCap": "The cap on the percentage that can be allocated to the long token - enforced for improving MM on v2 AMMs for both L&S tokens.",
          "upperBound": "The upper price that the LSP will operate within."
        }
      }
    },
    "title": "Linear Long Short Pair Financial Product Library.",
    "version": 1
  },
  "userdoc": {
    "errors": {
      "InvalidBound(uint256)": [
        {
          "notice": "`upperBound` has to be greater than zero."
        }
      ],
      "InvalidCap(uint256)": [
        {
          "notice": "`pctLongCap` has to be less than 1 ether."
        }
      ],
      "InvalidLSPAddress(address)": [
        {
          "notice": "`longShortPair` is not a valid LSP address."
        }
      ],
      "ParametersNotSet()": [
        {
          "notice": "Parameters not set for calling LSP."
        }
      ],
      "ParametersSet()": [
        {
          "notice": "Parameters already set for calling LSP."
        }
      ]
    },
    "kind": "user",
    "methods": {
      "percentageLongCollateralAtExpiry(int256)": {
        "notice": "Returns a number between 0 and 1e18 to indicate how much collateral each long and short token is entitled to per collateralPerPair."
      },
      "setLongShortPairParameters(address,uint256,uint256)": {
        "notice": "Enables any address to set the parameters for an associated financial product."
      }
    },
    "notice": "Adds settlement logic to create linear LSPs that have a capped percentage payable to the long (& short) token to make market making both the long and short tokens easier in a v2 style AMM.",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 2013,
        "contract": "contracts/ReserveLSPL.sol:ReserveLSPL",
        "label": "_notEntered",
        "offset": 0,
        "slot": "0",
        "type": "t_bool"
      },
      {
        "astId": 3052,
        "contract": "contracts/ReserveLSPL.sol:ReserveLSPL",
        "label": "longShortPairParameters",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_address,t_struct(ReserveLinearLongShortPairParameters)3047_storage)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_mapping(t_address,t_struct(ReserveLinearLongShortPairParameters)3047_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => struct ReserveLSPL.ReserveLinearLongShortPairParameters)",
        "numberOfBytes": "32",
        "value": "t_struct(ReserveLinearLongShortPairParameters)3047_storage"
      },
      "t_struct(ReserveLinearLongShortPairParameters)3047_storage": {
        "encoding": "inplace",
        "label": "struct ReserveLSPL.ReserveLinearLongShortPairParameters",
        "members": [
          {
            "astId": 3044,
            "contract": "contracts/ReserveLSPL.sol:ReserveLSPL",
            "label": "upperBound",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 3046,
            "contract": "contracts/ReserveLSPL.sol:ReserveLSPL",
            "label": "pctLongCap",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}
